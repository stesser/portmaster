#!/bin/sh

# Copyright (c) 2005-2012 Douglas Barton, All rights reserved
# Please see detailed copyright below

trap trap_exit INT

umask 022

progcmd="$0"			# actual invocation of this program for search in ps output
progname="${0##*/}"		# program name in messages
program="$(realpath $0)"	# full path to program for recursive calls

# Initialize crucial values for the parent, and export them for the children
try_read_rc () {
	local rc_file="$1"

	if [ -f "$rc_file" -a -s "$rc_file" ]; then
	 	set -o allexport
		. "$rc_file"
		set +o allexport
	fi
}

initial_init () {
	export PM_PARENT_PID=$$
	export TMPDIR=${TMPDIR:-/tmp} ; /bin/mkdir -p $TMPDIR
	export UPGRADE_TOOL=portmaster

	# /usr/local is needed in the path for make
	export PATH=/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/local/sbin
	[ -e /usr/X11R6 ] && [ ! -L /usr/X11R6 ] && PATH=$PATH:/usr/X11R6/bin
	[ -n "$CCACHE_PATH" -a -z "$NOCCACHE" ] && PATH="/usr/local/libexec/ccache:$PATH"

	if [ -r /etc/portmaster.rc ]; then
		pm_msg '' ; pm_msg "===>>> WARNING"
		pm_msg '       Your portmaster.rc is in /etc, however support for the file in this'
		pm_msg '       location has been removed.'
		pm_msg '' ; pm_msg '       The proper location for this file is /usr/local/etc'
		exit 1
	fi

	# Read a global rc file first
	try_read_rc /usr/local/etc/portmaster.rc

	# Allow the config file to be stored with the script
	try_read_rc "${program%/*})/portmaster.rc"

	# Read a local one next, and allow the command line to override
	try_read_rc "$HOME/.portmasterrc"

	my_environment=$(set)

	# If we are already root, unset this to avoid potential conflict
	if [ $(ps -o uid= $$) -eq 0 ]; then
		# default PM_SU_CMD to sudo if available and not running as root
		[ -z "$PM_SU_CMD" ] && export PM_SU_CMD=$(type -p sudo)
	else
		unset PM_SU_CMD PM_SU_VERBOSE
	fi
}

#=============== Begin functions we always want to have ===============

version () {
	local pkgname="%%PKGNAME%%"
	echo '' ; echo "===>>> Version ${pkgname##*-}"
}

# return 0 for parent process, 1 for child processes
not_in_child () {
	[ "$$" -eq "$PM_PARENT_PID" ]
}

fail () {
	pm_msg -e "\n===>>> $*"
	pm_msg "===>>> Aborting update"
	not_in_child && trap_exit fail
	safe_exit 1
}

# Global: portdir IPC_SAVE
trap_exit () {
	local from_fail="$1"

	pm_msg ''		# Helps if the previous message was 'echo -n'
	if [ -z "$from_fail" ]; then
		if [ -n "$portdir" ]; then
			pm_msg "===>>> Build/Install for $portdir exiting due to signal"
		else
			pm_msg "===>>> Exiting due to signal"
		fi
	fi

	if not_in_child; then
		[ -s "$IPC_SAVE" ] && . $IPC_SAVE

		local n=0
		while ps -axo pid,ppid,command | grep -v egrep |
		    egrep -q "(make -DBATCH checksum|/fetch |\[sh\])"; do
			# Protect from infinite loop if there is another fetch
			[ $n -gt 9 ] && break
			n=$(( $n + 1 ))
			kill_bad_children
		done
		if [ -n "$HIDE_BUILD" ]; then
			local logs file
			logs=$(/bin/ls -1 ${TMPDIR}/port_log-${PM_PARENT_PID}-*)

			if [ -n "$logs" ]; then
				pm_msg ''
				pm_msg "===>>> Build/Install logs available:"
				for file in $logs; do
					pm_msg "	$file"
				done
				pm_msg ''
			fi
		fi
	else
		# Signal the parent if a child trap'ed, or read the file if we are
		# an intermediate process.
		if ! pm_lstemp TEAC >/dev/null; then
			pm_mktemp TEAC >/dev/null	# Trap Exit Already Called
		else
			[ -s "$IPC_SAVE" ] && . $IPC_SAVE
		fi
	fi
	safe_exit 1
}

kill_bad_children () {
	local mypgid pid ppid pgid command ps_list ; IFS=' '

	mypgid=$(ps -o pgid= -p $PM_PARENT_PID)

	ps_list=$(ps -ax -o pid= -o ppid= -o pgid= -o command=)
	while read pid ppid pgid command; do
		[ "$pid" -gt 25 ] || continue
		case "$ppid" in
		1)
			case "$command" in
			*" $progcmd "*)
				pm_kill $pid ;;
			*'make -DBATCH checksum'*|*'/fetch '*|\[sh\])
				pm_kill -9 $pid ;; # <se> will "kill -9" all "fetch" and "[sh]" with ppid=1 !!!
			esac ;;
		*)
			[ $pgid -eq $mypgid ] || continue
			[ $pid -eq $PM_PARENT_PID ] && continue
			case "$command" in
			*" $progcmd "*)
				pm_kill $pid ;;
			*'make -DBATCH checksum'*|*'/fetch '*|\[sh\])
				pm_kill $pid ;;
			esac ;;
		esac
	done <<-EOF
	$(echo "$ps_list")
	EOF
}

wait_background_clean () {
	local count needws

	count=0
	while : ; do
		ps axww | grep '[ ]clean NOCLEANDEPENDS=ncd' >/dev/null || break	# make ... clean ...
		count=$(( $count + 1 ))
		if [ $count -eq 1 ]; then
			pm_msg "===>>> Waiting for background 'make clean' processes to finish"
			needws=needws
		elif [ $count -eq 10 ]; then
			count=0
		fi
		sleep 2
	done

	pm_v "===>>> Removing empty directories from WRKDIRPREFIX"
	[ -n "$needws" ] && pm_msg '' || pm_v
	find $PM_WRKDIRPREFIX -depth -mindepth 1 -type d -empty -delete 2>/dev/null
}

print_installed () {
	local INSTALLED_LIST

	INSTALLED_LIST="$*"
	if [ -n "$UPDATE_ALL" -o -n "$PM_MULTI_PORTS" ]; then
		show_list=all
	else
		case "$INSTALLED_LIST" in
		*\\n\\t*)
			show_list=all ;;
		*\\n)
			show_list=one
			if [ -z "$ilist" ]; then
				ilist="${INSTALLED_LIST#\\t}"
				ilist="${ilist%\\n}"
			fi ;;
		esac
	fi
	if [ -n "$PM_LOG" ]; then
		if [ -w "$PM_LOG" ] || touch "$PM_LOG"; then
			echo '' >> $PM_LOG
		elif [ -e "$PM_LOG" -a ! -w "$PM_LOG" ]; then
			pm_msg "===>>> Warning: $PM_LOG exists, but is not writable"
			unset PM_LOG
		elif [ -e "$PM_LOG" -o -L "$PM_LOG" ]; then
			pm_msg "===>>> Warning: $PM_LOG exists, but is not a regular file"
			unset PM_LOG
		else
			mv $(pm_mktemp pm_log) $PM_LOG
		fi
		[ -n "$PM_LOG" ] && date >> $PM_LOG
	fi
	case "$show_list" in
	all)
		pm_msg "===>>> The following actions were performed:"
		pm_msg -e $INSTALLED_LIST
		[ -n "$PM_LOG" ] && echo -e ${INSTALLED_LIST%\\n} >> $PM_LOG ;;
	one)
		pm_msg "===>>> $ilist complete" ; pm_msg ''
		[ -n "$PM_LOG" ] && echo "	$ilist" >> $PM_LOG ;;
	esac
}

# Global: DI_FILES pdb NB_DELETE pbu DISPLAY_LIST INSTALLED_LIST build_deps_il
parent_exit () {
	local with_msg need_kbc files f count needws DISCARD show_list

	with_msg="$1"

	[ -s "$DI_FILES" ] && { grep -q '%%%%%%%%%%%%' $DI_FILES || need_kbc=need_kbc_dif; }

	[ -n "$FETCH_ONLY" -a -z "$FETCH_ONLY_DONE" ] && need_kbc=need_kbc_fo

	if [ -z "$with_msg" ]; then
		if [ -n "$PM_URB" -o -n "$PM_FORCE" ]; then
			files=$(find $pdb -type f -name PM_UPGRADE_DONE_FLAG)
			if [ -n "$files" ]; then
				pm_sv Deleting \'install complete\' flags
				pm_find_s $pdb -type f -name PM_UPGRADE_DONE_FLAG -delete
				pm_find_s $pdb -type d -depth 1 -empty ! -path \*\.zfs/\* -delete 2>/dev/null
			fi
		fi
		if [ -z "$BACKUP" -a -z "$NO_BACKUP" -a -n "$NB_DELETE" ]; then
			pm_sv 'Deleting safety packages for successful installs\n'
			pm_cd $pbu || fail "Cannot cd to $pbu"
			pm_rm_s $NB_DELETE
		fi
	else
		need_kbc=need_kbc_ec
	fi

	[ -n "$need_kbc" ] && kill_bad_children

	if [ -n "$pbu" -a -d "$pbu" -a -z "$(ls -A $pbu)" ]; then
		pm_sv 'Removing empty backup package directory'
		pm_rmdir_s "$pbu"
	fi

	pm_rmtemp "*"

	if [ -n "$PM_WRKDIRPREFIX" ] && [ -n "$PM_BUILDING" -a -z "$with_msg" ]; then
		wait_background_clean
	fi

	case "$DISPLAY_LIST" in
	*' '*)
		if [ -n "$with_msg" ]; then
			pm_msg "===>>> There are messages from installed ports to display,"
			pm_msg "       but first take a moment to review the error messages"
			pm_msg -n "       above.  Then press Enter when ready to proceed. "
			read DISCARD
			pm_msg ''
		fi

		: ${PAGER:='less -e'}
		(
			pkg query "===>>> pkg-message for %n-%v\n%M" $DISPLAY_LIST
			echo "===>>> Done displaying pkg-message files"
			echo ''
		) | $PAGER ;;
	esac

	if [ -n "$INSTALLED_LIST" ]; then
		print_installed "$INSTALLED_LIST"
	fi

	if [ -n "$build_deps_il" ]; then
		pm_msg "===>>> Deleting installed build-only dependencies"
		cd
		pm_pkg_delete_s $build_deps_il
		pm_msg ''
	fi

	if [ -n "$with_msg" -a -n "${PM_NEEDS_UPDATE# }" -a -n "$PM_BUILDING" -a -z "$FETCH_ONLY" ]; then
		echo "$progname <flags>${PM_NEEDS_UPDATE}" > ${TMPDIR}/portmasterfail.txt
		pm_msg ''
		pm_msg "===>>> You can restart from the point of failure with this command line:"
		pm_msg "       $progname <flags>${PM_NEEDS_UPDATE}"
		pm_msg ''
		pm_msg "This command has been saved to ${TMPDIR}/portmasterfail.txt"
		pm_msg ''
	fi
}

# Global: grep_deps IPC_SAVE DISPLAY_LIST INSTALLED_LIST build_deps_il portdir
# Global: build_only_dl_g run_dl_g rundep_list num_of_deps build_l NO_DEP_UPDATES CUR_DEPS
# Global: dep_of_deps PM_NEEDS_UPDATE INTERACTIVE_UPDATE INTERACTIVE_YES INTERACTIVE_NO
# Global: PM_URB PM_URB_UP PM_URB_DONE
safe_exit () {
	local with_msg i f

	with_msg="$1"

	[ -n "$grep_deps" ] && pm_unlink $grep_deps

	if not_in_child; then
		parent_exit $with_msg
	else
		# Save state for the parent process to read back in
		> $IPC_SAVE
		if [ -z "$PM_FIRST_PASS" ]; then
			echo "DISPLAY_LIST='$DISPLAY_LIST'" >> $IPC_SAVE
			echo "INSTALLED_LIST='$INSTALLED_LIST'" >> $IPC_SAVE

			[ -n "$PM_DEL_BUILD_ONLY" ] &&
				echo "build_deps_il='$build_deps_il'" >> $IPC_SAVE

			# Do not remove a child from the list if we trapped or failed
			if [ -z "$with_msg" ]; then
				for i in $PM_NEEDS_UPDATE; do
					[ "$i" = "$portdir" ] && continue
					pnu_temp="${pnu_temp}${i} "
				done
				PM_NEEDS_UPDATE=" ${pnu_temp}"
			fi

			[ -z "$NO_BACKUP" -a -z "$BACKUP" ] && echo "NB_DELETE='$NB_DELETE'" >> $IPC_SAVE
		else
			if [ "$PM_BUILD_ONLY_LIST" = pmp_doing_build_deps ]; then
				echo "build_only_dl_g='$build_only_dl_g'" >> $IPC_SAVE
				echo "run_dl_g='$run_dl_g'" >> $IPC_SAVE
				rundep_list=$(uniquify_list $rundep_list)
				echo "rundep_list='$rundep_list'" >> $IPC_SAVE
				for f in $rundep_list; do
					eval echo "export $f=\'\$$f\'" >> $IPC_SAVE
					eval echo "export ${f}_p=\'\$${f}_p\'" >> $IPC_SAVE
				done
			fi

			# Do these here so +IGNOREME can modify them
			echo "num_of_deps='$num_of_deps'" >> $IPC_SAVE
			echo "build_l='$build_l'" >> $IPC_SAVE
			[ -z "$NO_DEP_UPDATES" ] && echo 'unset NO_DEP_UPDATES' >> $IPC_SAVE
		fi
		echo "CUR_DEPS='$CUR_DEPS'" >> $IPC_SAVE
		echo "dep_of_deps='$dep_of_deps'" >> $IPC_SAVE
		echo "PM_NEEDS_UPDATE='$PM_NEEDS_UPDATE'" >> $IPC_SAVE
		if [ -n "$INTERACTIVE_UPDATE" ]; then
			echo "INTERACTIVE_YES='$INTERACTIVE_YES'" >> $IPC_SAVE
			echo "INTERACTIVE_NO='$INTERACTIVE_NO'" >> $IPC_SAVE
		fi
		[ -n "$PM_URB" -o -n "$PM_URB_UP" ] && echo "PM_URB_DONE='$PM_URB_DONE'" >> $IPC_SAVE
	fi

	exit ${1:-0}
} # safe_exit()

flavor_part	() { expr "$1" : ".*@" >/dev/null && echo "${1#*@}"; }
dir_part	() { echo "${1%%@*}"; }
export_flavor	() { local flavor="$1"; if [ "$FLAVOR" != "$flavor" ]; then
			pm_v "===>>> Setting FLAVOR to '$flavor' (was '$FLAVOR')";
			export FLAVOR="$flavor"; fi; }
pm_cd		() { builtin cd $1 2>/dev/null || return 1; }
pm_cd_pd	() { [ -n "$PM_INDEX_ONLY" ] && return 2;
			[ -n "$1" ] && builtin cd $pd/$(dir_part $1) 2>/dev/null ||
			fail "Cannot cd to port directory: '$dir'"; }
pm_isdir	() { builtin test -d "$1"; }
pm_isdir_pd	() { local dir=$pd/$(dir_part "$1");
			builtin test -d "$dir"; }
pm_kill		() { kill $* >/dev/null 2>/dev/null; }
pm_make		() { ( unset CUR_DEPS INSTALLED_LIST PM_DEPTH build_l PM_URB_LIST;
			/usr/bin/nice /usr/bin/make $PM_MAKE_ARGS $*; ); }
pm_make_b	() { /usr/bin/make $PM_MAKE_ARGS BEFOREPORTMK=bpm $*; }
pm_make_g	() { pm_make_b -f /usr/share/mk/bsd.port.mk "$*" 2>/dev/null; }
pm_mktemp	() { local f=$(/usr/bin/mktemp -t f-${PM_PARENT_PID}-$1 2>&1) ||
			fail "mktemp for $1 failed:\n       ${f#mktemp: }"; echo "$f"; }
pm_lstemp	() { local type=$1 key=${2:-*}
			/bin/ls -1 ${TMPDIR:-/tmp}/f-${PM_PARENT_PID}-${type}.${key} 2>/dev/null; }
pm_rmtemp	() { local files=$(pm_lstemp "$@") && rm $files 2>/dev/null; }
pm_unlink	() { [ -e "$1" ] && /bin/unlink $1; }
pm_islocked	() { [ -n "$1" ] || return 1;
			[ -e "$pdb/$1/+IGNOREME" ] && pkg info -e "$1" ||
			[ $(pkg query %k "$1") -eq 1 ]; }

# Superuser versions for commands that need root privileges

pm_find_s	() { $PM_SU_CMD /usr/bin/find $*; }
pm_install_s	() { $PM_SU_CMD /usr/bin/install -p -o root -g wheel -m 644 $1 $2; }
pm_make_s	() { ( unset -v CUR_DEPS INSTALLED_LIST PM_DEPTH build_l PM_URB_LIST;
			$PM_SU_CMD /usr/bin/nice /usr/bin/make $PM_MAKE_ARGS $*; ); }
pm_mkdir_s	() { $PM_SU_CMD /bin/mkdir -p $1; }
pm_pkg_delete_s	() { $PM_SU_CMD /usr/local/sbin/pkg delete -yf $*;
			for d in $*; do pm_rm_s -rf $pdb/$d; done; }
pm_rm_s		() { $PM_SU_CMD /bin/rm $*; }
pm_rmdir_s	() { $PM_SU_CMD /bin/rmdir $*; }
pm_unlink_s	() { [ -e "$1" ] && $PM_SU_CMD /bin/unlink $1; }

pm_msg		() { echo -e "$*" >&2; }
pm_v		() { [ -n "$PM_VERBOSE" ] && echo -e "$*" >&2; }
pm_sv		() { [ -n "$PM_SU_VERBOSE" ] && echo -e "===>>> SU $*" >&2; }

# set operations operating on global variables

set_print () {
	local set_name="_set_${1}_"
	local IFS="|"
set -f
	eval set -- \$${set_name}
set +f
	shift
	for value in "$@"; do
		echo "$value"
	done
}

set_add () {
set -f
	local set_name="_set_${1}_"
	shift
	for value in "$@"; do
		case $value in
		*'|'*)
			echo "set_add: Illegal character '|' in value '$value'" >&2
			exit 0 ;;
		esac
		eval local set_values="\$${set_name}"
		case ${set_values:=|} in
		*"|$value|"*)
			continue ;;
		esac
		eval ${set_name}="'$set_values$value|'"
	done
set +f
}

set_rm () {
	local set_name="_set_${1}_"
	local set_values
	shift
	eval set_values="\$${set_name}"
	for value in "$@"; do
		case $set_values in
		*"|$value|"*|*"|$value	"*)
			case $value in
			*'*'*|*'?'*)
				value=$(echo "$value" | sed -E 's:(\*|\?):[\1]:g') ;;
			esac
			set_values="${set_values%$value*}${set_values#*$value|}" ;;
		esac
	done
	eval ${set_name}="'$set_values'"
}

set_contains () {
	local set_name="_set_${1}_"
	local value="$2"
	local set_values
	eval set_values="\$${set_name}"
	case $set_values in
	*"|$value|"*|*"|$value	"*)
		return 0 ;;
	esac
	return 1
}

set_merge () {
	local value
	while read value; do
		set_add $1 "$value"
	done <<-EOF
	$(set_print $2)
EOF
}

set_intersect () {
	local set_name="_set_${1}_"
	local value set_values
	while read value; do
		set_contains $1 "$value" && set_values="${set_values:-|}$value|"
	done <<-EOF
	$(set_print $2)
EOF
	eval ${set_name}="'$set_values'"
}

set_exclude () {
	local value
	while read value; do
		set_rm $1 "$value"
	done <<-EOF
	$(set_print $2)
EOF
}

set_clear () {
	eval unset "_set_${1}_"
}

# ----- end of set operations

# dict operations operating on global variables

dict_set () {
	local dict="_dict_$1"
	local key="$2"
	local value="$3"
	set_rm "$dict" "$key"
	set_add "$dict" "$key	$value"
}

dict_del () {
	set_rm "_dict_$1" "$2"
}

dict_get () {
	local dict="_dict_$1"
	local key="$2"
	local value
	while read value; do
		case $value in
		"$key	"*)
			echo ${value#*	}
			return 0 ;;
		esac
	done <<-EOF
	$(set_print $dict)
EOF
	return 1
}

dict_keys () {
	local dict="_dict_$1"
	local key
	while read key; do
		echo "${key%	*}"
        done <<-EOF
	$(set_print $dict)
EOF
}

# ----- end of dict operations


# Do this here so we can have a reasonably good guess.
# May be modified below.
init_pd_var () {
	if [ -z "$pd" ]; then
		if [ -z "$PORTSDIR" ]; then
			pd=$(pm_make_g -V PORTSDIR 2>/dev/null)
			[ -z "$pd" ] && pm_isdir /usr/ports && pd=/usr/ports
		else
			pd=$PORTSDIR
		fi
	fi
	if [ -n "$pd" ]; then
		[ ! -r "${pd}/Mk/bsd.port.mk" ] &&
			fail "The ports directory ($pd) does not seem to contain a ports tree"
		export pd
	fi
}

init_pdb_var () {
	if [ -z "$pdb" ]; then
		if [ -z "$PKG_DBDIR" ]; then
			pm_isdir /var/db/pkg && pdb=/var/db/pkg
			[ -z "$pdb" ] &&
				pdb=$(pm_make_g -V PKG_DBDIR 2>/dev/null)
		else
			pdb=$PKG_DBDIR
		fi
		if [ -z "$pdb" ]; then
			if pm_isdir /var/db/pkg; then
				pdb='/var/db/pkg'
			else
				fail 'The value of PKG_DBDIR cannot be empty'
			fi
		fi
	fi
	export pdb
}

init_port_dbdir_var () {
	[ -z "$port_dbdir" ] && pm_isdir /var/db/ports && port_dbdir=/var/db/ports
	[ -z "$port_dbdir" ] && port_dbdir=$(pm_make_g -V PORT_DBDIR 2>/dev/null)
	[ -n "$port_dbdir" ] && export port_dbdir
}

init_packages_var () {
	# Global: PACKAGES

	[ -n "$PACKAGES" ] && return

	PACKAGES=$(pm_make_g -V PACKAGES 2>/dev/null)
	if [ -z "$PACKAGES" ]; then
		if [ -d "${pd}/packages" -a -w "${pd}/packages" ]; then
			PACKAGES="${pd}/packages"
		else
			if [ -d "${pd}/" -a -w "${pd}/" ]; then
				PACKAGES="${pd}/packages"
			else
				fail 'The value of PACKAGES cannot be empty and the directory must be writable'
			fi
		fi
	fi
	export PACKAGES
}

init_pbu_var () {
	# Global: pbu

	[ -n "$FETCH_ONLY" ] && return

	init_packages_var

	[ -n "$NO_BACKUP" ] && return

	export pbu=$PACKAGES/portmaster-backup

	if ! pm_isdir "$pbu"; then
		pm_sv Creating $pbu
		pm_mkdir_s $pbu
	fi
}

usage () {
	local pd pdb port_dbdir

	[ -z "$pd" ] && pd=/usr/ports
	[ -z "$pdb" ] && pdb=/var/db/pkg
	[ -z "$port_dbdir" ] && port_dbdir=/var/db/ports

	version
	echo ''
	echo 'Usage:'
	echo "Common flags: [--force-config -CGHKgntvw -[B|b] -[f|i] -[D|d]]"
	echo "    [[[--packages|-P]|[--packages-only|-PP]] | [--packages-build]]"
	echo "    [--packages-if-newer] [--delete-build-only] [--always-fetch]"
	echo "    [--local-packagedir=<path>] [--packages-local] [--delete-packages]"
	echo "    [--no-confirm] [--no-term-title] [--no-index-fetch]"
	echo "    [--index|--index-first|--index-only] [-m <arguments for make>]"
	echo "    [-x <glob pattern to exclude from building>]"
	echo "$progname [Common flags] <full name of port directory in $pdb>"
	echo "$progname [Common flags] <full path to $pd/foo/bar>"
	echo "$progname [Common flags] <glob pattern of directories in $pdb>"
	echo "$progname [Common flags] [--update-if-newer] Multiple full names/paths"
	echo "         from $pdb|$pd and/or multiple globs from $pdb"
	echo ''
	echo "$progname [Common flags] . [Use in $pd/foo/bar to build that port]"
	echo ''
	echo "$progname [Common flags] -a"
	echo ''
	echo "$progname --show-work [-Gv] [-m <args>] <single port, as above>"
	echo ''
	echo "$progname [Common flags] -o <new port dir in $pd> <installed port>"
	echo "$progname [Common flags] [-R] -r <name/glob of port directory in $pdb>"
	echo '         (-r <port> can be specified multiple times)'
	echo ''
	echo "$progname -l"
	echo "$progname [--index-only [-t]] -L"
	echo ''
	echo "$progname --list-origins"
	echo ''
	echo "$progname [--force-config|-G] [-P|-PP] [-aftv] -F"
	echo ''
	echo "$progname [-n|y] [-b] [-D|d] -e <name/glob of a single port in $pdb>"
	echo "$progname [-n|y] [-b] [-D|d] -s"
	echo ''
	echo "$progname [-n|y] [-t] --clean-distfiles"
	echo ''
	echo "$progname [-n|y] [--index|--index-only] --clean-packages"
	echo ''
	echo "$progname [-n|y] [--index|--index-only] [-v] --check-depends"
	echo ''
	echo "$progname [-n|y] [-v] --check-port-dbdir"
	echo ''
	echo "$progname -h|--help"
	echo "$progname --version"
	echo ''
	echo "--force-config run 'make config' for all ports (overrides -G)"
	echo "-C prevents 'make clean' from being run before building"
	echo "-G prevents 'make config'"
	echo "-H hide details of the port build and install in a log file"
	echo "-K prevents 'make clean' from being run after building"
	echo '-B prevents creation of the backup package for the installed port'
	echo '-b create and keep a backup package of an installed port'
	echo '-g create a package of the new port'
	echo '-n run through all steps, but do not make or install any ports'
	echo '-t recurse dependencies thoroughly, using all-depends-list'
	echo '-v verbose output'
	echo '-w save old shared libraries before deinstall'
	echo '[-R] -f always rebuild ports (overrides -i)'
	echo '-i interactive update mode -- ask whether to rebuild ports'
	echo '-D no cleaning of distfiles'
	echo '-d always clean distfiles'
	echo "-m <arguments for the 'make' command line>"
	echo "-x <avoid building or updating ports that match this pattern>"
	echo '   Can be specified more than once'
	echo ''
	echo '--no-confirm do not ask user to confirm list of ports to be'
	echo '   installed and/or updated before proceeding'
	echo '--no-term-title do not update the xterm title bar'
	echo ''
	echo '--no-index-fetch skip fetching the INDEX file'
	echo '--index use INDEX-[7-9] exclusively to check if a port is up to date'
	echo '--index-first use the INDEX for status, but double-check with the port'
	echo '--index-only do not try to use /usr/ports'
	echo ''
	echo '--delete-build-only delete ports that are build-only dependencies'
	echo '   after a successful run, only if installed this run'
	echo ''
	echo '--update-if-newer (only for multiple ports listed on command line)'
	echo '   do not rebuild/reinstall if the installed version is up to date'
	echo ''
	echo '-P|--packages use packages, but build port if not available'
	echo '-PP|--packages-only fail if no package is available'
	echo '--packages-build use packages for all build dependencies'
	echo '--packages-if-newer use package if newer than installed even'
	echo '   if the package is not the latest according to the ports tree'
	echo '--always-fetch fetch package even if it already exists locally'
	echo '--local-packagedir=<path> where local packages can be found,'
	echo '   will fall back to fetching if no local version exists'
	echo '--packages-local use packages from --local-packagedir only'
	echo '--delete-packages after installing from a package, delete it'
	echo ''
	echo '-a check all ports, update as necessary'
	echo ''
	echo '--show-work list what ports are and would be installed'
	echo ''
	echo '-o replace the installed port with a port from a different origin'
	echo '[-R] -r rebuild port, and all ports that depend on it'
	echo '-R used with -[rf] to skip ports updated on a previous run'
	echo ''
	echo '-l list all installed ports by category'
	echo '-L list all installed ports by category, and search for updates'
	echo ''
	echo "--list-origins list directories from $pd for root and leaf ports"
	echo ''
	echo '[--force-config|-G] [-aftv] -F fetch distfiles only'
	echo ''
	echo '-n answer no to all user prompts for the features below'
	echo '-y answer yes to all user prompts for the features below'
	echo ''
	echo '[-n|y] [-b] [-D|d] -e expunge one port via pkg delete, and remove its distfiles'
	echo '[-n|y] [-b] [-D|d] -s clean out stale ports that used to be depended on'
	echo ''
	echo '[-t] [-n] --clean-distfiles offer to delete stale distfiles'
	echo '[-t] -y --clean-distfiles delete stale distfiles without prompting'
	echo '   with -t distfile is valid from any port, not just those installed'
	echo ''
	echo '[--index|--index-only] [-n] --clean-packages offer to delete stale packages'
	echo '[--index|--index-only] -y --clean-packages delete without prompting'
	echo '   --index-only is required if no ports tree is available'
	echo ''
	echo '[-n|y] [-v] --check-depends cross-check and update dependency info for all ports'
	echo ''
	echo "[-n|y] [-v] --check-port-dbdir check for stale entries in $port_dbdir"
	echo ''
	echo '-h|--help display this help message'
	echo '--version display the version number'
	echo ''
	echo 'Please see the portmaster(8) man page for more information'
	safe_exit ${1:-1}
}

globstrip () {
	local in
	in=${1%[*]}
	in=${in%\\}
	echo $in
}

# Takes a pattern as input
# Return values:
# 0 - Matched one and only one directory in $pdb
# 1 - No match
# 2 - Matched multiple directories
#
find_glob_dirs () {		# should return glob_dirs
	local pattern glob_dirs

	pattern=$(globstrip $1)
	glob_dirs=$(pkg query -g "%n-%v" ${pattern}\*)

	echo "$glob_dirs"

	case "$glob_dirs" in
	*'
'*)		# Match a newline in multiple responses from find
		return 2 ;;
	'')
		return 1 ;;
	*)
		return 0 ;;
	esac
}

origin_from_pdb () {
	local flavor pkgname

	pkgname="$1"
	flavor=$(pkg annotate -Sq "$pkgname" flavor)
	pkg query '%o'"${flavor:+@$flavor}" "$pkgname" 2>/dev/null && return 0

	case "$pkgname" in
	bsdpan-*)
		return 3 ;;
	esac

	if pm_islocked "$pkgname"; then
		if [ -n "$PM_VERBOSE" -o -n "$LIST_ORIGINS" ]; then
			# An error above doesn't necessarily mean there's
			# a problem in +MANIFEST, so don't mention it
			pm_msg "	===>>> No origin available for $pkgname"
			pm_msg "	===>>> $pdb/$pkgname/+IGNOREME exists"
			pm_msg ''
		fi
		return 2
	else
		# Same as above
		pm_msg "	===>>> No origin available for $pkgname"
		pm_msg ''
	fi
	return 1
}

#=============== End functions we always want to have ===============
#=============== Begin Command Line Option Processing ===============

set_packages_mode () {
	local conflict

	case "$1:$PM_PACKAGES:$PM_PACKAGES_BUILD" in
	first::|only::)
		export PM_PACKAGES=$1 ;;
	newer::)
		export PM_PACKAGES=$1
		export PM_PACKAGES_NEWER=pmp_newer ;;
	local::)
		export PM_PACKAGES=$1
		export PM_PACKAGES_LOCAL=pmp_local ;;
	build:*:)
		unset PM_PACKAGES
		export PM_PACKAGES_BUILD=pmp_build ;;
	first:only:*|only:first:*)
		conflict="-P/--packages and -PP/--packages-only" ;;
	build:only:*|build:first:*|only:*:?*|first:*:?*)
		conflict="--packages-build option and the -P[P]" ;;
	newer:only:*|only:newer:*)
		conflict="--packages-if-newer and -PP/--packages-only" ;;
	esac
	[ -n "$conflict" ] && fail "The $conflict options are mutually exclusive"
}

cross_idx () {
	local e1

	e1='The --index, --index-first, and --index-only options are mutually exclusive'

	case "$*" in
	*--index*--index*)
		fail $e1 ;;
	index\ *)
		[ -n "$PM_INDEX_FIRST" -o -n "$PM_INDEX_ONLY" ] && fail $e1 ;;
	first\ *)
		[ -n "$PM_INDEX_ONLY" ] && fail $e1 ;;
	only\ *)
		[ -n "$PM_INDEX_FIRST" ] && fail $e1 ;;
	esac
}

check_longopts () {
	local var
	for var in "$@" ; do
		case "$var" in
		-PP[A-Za-z0-9]*|-*[A-Za-z0-9]PP*)
			fail "The -PP option must stand alone" ;;
		--packages)		set_packages_mode first ;;
		-PP|--packages-only)	set_packages_mode only ;;
		--packages-build)	set_packages_mode build ;;
		--packages-if-newer)	set_packages_mode newer ;;
		--packages-local)	set_packages_mode local ;;
		--always-fetch)		export PM_ALWAYS_FETCH=pm_always_fetch ;;
		--backup-format=*)	export BACKUP_FORMAT=${var#--backup-format=} ;;
		--local-packagedir=*)	export LOCAL_PACKAGEDIR=${var#--local-packagedir=} ;;
		--delete-packages)	export PM_DELETE_PACKAGES=pm_delete_packages ;;
#		--flavor=*)		PM_FLAVOR=${var#--flavor=} ;;
		--update-if-newer)	export PM_UPDATE_IF_NEWER=pm_update_if_newer ;;
		--delete-build-only)	export PM_DEL_BUILD_ONLY=pm_dbo ;;
		--no-confirm)		export PM_NO_CONFIRM=pm_no_confirm ;;
		--no-term-title)	export PM_NO_TERM_TITLE=pm_no_term_title ;;
		--no-index-fetch)	PM_NO_INDEX_FETCH=pm_no_index_fetch ;;
		--index)		cross_idx "index $*"
					export PM_INDEX=pm_index ;;
		--index-first)		cross_idx "first $*"
					export PM_INDEX=pm_index ; export PM_INDEX_FIRST=pm_index_first ;;
		--index-only)		cross_idx "only $*"
					export PM_INDEX=pm_index ; export PM_INDEX_ONLY=pm_index_only ;;
		--help)			usage 0 ;;
		--version)		version ; exit 0 ;;
		--clean-distfiles)	CLEAN_DISTFILES=clean_distfiles ;;
		--clean-distfiles-all)	echo "===>>> The -all form is deprecated, please use -y instead"
					CLEAN_DISTFILES=clean_distfiles ; PM_YES=yopt ;;
		--clean-packages)	CLEAN_PACKAGES=clean_packages ;;
		--clean-packages-all)	echo "===>>> The -all form is deprecated, please use -y instead"
					CLEAN_PACKAGES=clean_packages ; PM_YES=yopt ;;
		--check-depends)	CHECK_DEPENDS=check_depends ;;
		--check-port-dbdir)	CHECK_PORT_DBDIR=check_port_dbdir ;;
		--list-origins)		LIST_ORIGINS=list_origins ;;
		--show-work)		SHOW_WORK=show ; PM_THOROUGH=thorough ;;
		--force-config)		export PM_FORCE_CONFIG=pm_force_config ;;
		--*)			echo "Illegal option $var" ; echo ''
					echo "===>>> Try $progname --help"; exit 1 ;;
		*)			shortopts="$shortopts $var" ;;
		esac
	done
}

check_opts () {
	local COMMAND_LINE_ARGUMENT glob_dirs
	# Save switches for potential child processes
	while getopts 'BCDFGHKLPRabde:fghilm:nop:r:stvwx:y' COMMAND_LINE_ARGUMENT; do
		case "${COMMAND_LINE_ARGUMENT}" in
		B)	NO_BACKUP=Bopt; ARGS="-B $ARGS" ;;
		C)	DONT_PRE_CLEAN=Copt; ARGS="-C $ARGS" ;;
		D)	DONT_SCRUB_DISTFILES=Dopt; ARGS="-D $ARGS" ;;
		F)	FETCH_ONLY=Fopt; ARGS="-F $ARGS" ;;
		G)	[ -z "$PM_FORCE_CONFIG" ] && {
				PM_NO_MAKE_CONFIG=Gopt; ARGS="-G $ARGS"; } ;;
		H)	HIDE_BUILD=Hopt; ARGS="-H $ARGS" ;;
		K)	DONT_POST_CLEAN=Kopt; ARGS="-K $ARGS" ;;
		L)	LIST_PLUS=Lopt ;;
		P)	set_packages_mode first ;;
		R)	RESTART=Ropt ; ARGS="-R $ARGS" ;;
		a)	UPDATE_ALL=aopt ;;
		b)	BACKUP=bopt; ARGS="-b $ARGS" ;;
		d)	ALWAYS_SCRUB_DISTFILES=dopt; ARGS="-d $ARGS" ;;
		e)	EXPUNGE=$OPTARG ;;
		f)	export PM_FORCE=fopt ;;
		g)	MAKE_PACKAGE=gopt; ARGS="-g $ARGS" ;;
		h)	usage 0 ;;
		i)	INTERACTIVE_UPDATE=iopt; ARGS="-i $ARGS" ;;
		l)	LIST=lopt ;;
		m)	export PM_MAKE_ARGS=$OPTARG	# For 'make checksum'
			ARGS="-m $PM_MAKE_ARGS $ARGS" ;;
		n)	NO_ACTION=nopt; ARGS="-n $ARGS" ;;
		o)	REPLACE_ORIGIN=oopt ;; # -o should take a parameter and $OPTARG should be assigned here
		p)	fail 'The -p option has been deprecated' ;;
		r)	PM_URB=ropt
			if [ -d "$pdb/$OPTARG" ] && pkg info -e $OPTARG; then
				glob_dirs=$OPTARG
			else
				case "$OPTARG" in
				*/*)
					fail 'The argument to -r must be a package name, or a glob pattern' ;;
				esac
				glob_dirs=$(find_glob_dirs $OPTARG)
				case $? in
				1)
					fail "$OPTARG is not installed" ;;
				2)
					fail 'The argument to -r must match only one port' ;;
				esac
			fi
			PM_URB_IPORTS="${PM_URB_IPORTS}${glob_dirs##*/} "
			PM_URB_ORIGINS="${PM_URB_ORIGINS}$(origin_from_pdb ${glob_dirs##*/}) " ;;
		s)	CLEAN_STALE=sopt ;;
		t)	PM_THOROUGH=topt; ARGS="-t $ARGS" ;;
		v)	PM_VERBOSE=vopt; ARGS="-v $ARGS" ;;
		w)	SAVE_SHARED=wopt; ARGS="-w $ARGS" ;;
		x)	case "$OPTARG" in
			-*)
				fail 'The -x option requires an argument' ;;
			esac
			PM_EXCL="${PM_EXCL}$(globstrip ${OPTARG}) " ;;
		y)	PM_YES=yopt; ARGS="-y $ARGS" ;;
		*)	echo '' ; echo "===>>> Try $progname --help"; exit 1 ;;
		esac
	done
	shift $(( $OPTIND - 1 ))
	worklist="$*"
}

test_command_line () {
	local var envar

	for var in $my_environment; do
		case "$var" in
		${1}=*)
			envar=$1 ;;
		${2}=*)
			envar=$2 ;;
		esac
	done

	if [ -n "$envar" ]; then
		unset $envar
		return 0
	fi

	return 1
}

# Error checking for getopts
check_opt_errs () {
	[ -n "$PM_YES" -a -n "$NO_ACTION" ] && fail 'The -y and -n options are mutually exclusive'

	[ -n "$PM_FORCE" -a -n "$INTERACTIVE_UPDATE" ] &&
		fail "The -f and -i options are mutually exclusive"
	if [ -n "$BACKUP" -a -n "$NO_BACKUP" ]; then
		test_command_line NO_BACKUP BACKUP ||
			fail "The -b and -B options are mutually exclusive"
	fi
	if [ -n "$ALWAYS_SCRUB_DISTFILES" -a -n "$DONT_SCRUB_DISTFILES" ]; then
		test_command_line ALWAYS_SCRUB_DISTFILES DONT_SCRUB_DISTFILES ||
			fail "The -d and -D options are mutually exclusive"
	fi

	if [ -n "$LIST" -o -n "$LIST_PLUS" ]; then
		if [ -n "$FETCH_ONLY" -o -n "$RESTART" -o -n "$UPDATE_ALL" -o \
			-n "$EXPUNGE" -o -n "$PM_FORCE" -o -n "$NO_ACTION" -o \
			-n "$REPLACE_ORIGIN" -o -n "$PM_URB" -o -n "$CLEAN_STALE" ]; then
			fail 'The -[lL] options are not compatible with -FRaefnors'
		fi
		[ $# -gt 0 ] && fail 'The -[lL] options are not compatible with updates or installs'
	fi
}

# Global: INDEXFILE INDEXDIR PM_INDEX_ONLY
fetch_index () {
		if [ -z "$INDEXFILE" ]; then
			local ver=$(uname -r)
			INDEXFILE=INDEX-${ver%%\.*}
		fi

		[ -z "$INDEXDIR" -a -n "$PM_INDEX_ONLY" -a -z "$pd" ] && INDEXDIR="$TMPDIR"

		PM_INDEX="${INDEXDIR:=$pd}/${INDEXFILE}"

		if [ -z "$PM_NO_INDEX_FETCH" ]; then
			: ${FETCHINDEX:='fetch -am -o'}
			: ${MASTER_SITE_INDEX:='http://www.FreeBSD.org/ports/'}

			do_index_fetch=yes_index_fetch

			index_time=$(stat -f '%Um' ${PM_INDEX}.bz2 2>/dev/null)

			if [ -n "$index_time" ]; then
				# If root, this will succeed either way
				if $FETCHINDEX ${PM_INDEX}.bz2 ${MASTER_SITE_INDEX}${INDEXFILE}.bz2 2>/dev/null; then
					unset do_index_fetch
					newindex="${PM_INDEX}.bz2"
				fi
			fi

			if [ -n "$do_index_fetch" ] ||
				   [ ${index_time:-0} -ne $(stat -f '%Um' ${PM_INDEX}.bz2 2>/dev/null) ]; then
				dli=$(/usr/bin/mktemp -d ${TMPDIR}/d-${PM_PARENT_PID}-index 2>/dev/null) ||
					fail "Could not create a temporary directory for index in $TMPDIR"
				if [ -n "$do_index_fetch" ]; then
					ift="$FETCHINDEX ${dli}/${INDEXFILE}.bz2 ${MASTER_SITE_INDEX}${INDEXFILE}.bz2"
					$ift || fail Could not perform $ift
					unset ift
					newindex="${dli}/${INDEXFILE}.bz2"
				fi

				bunzip2 --keep < $newindex > ${dli}/$INDEXFILE
				if [ -w "${INDEXDIR}/" ]; then
					pm_unlink $PM_INDEX
					mv ${dli}/$INDEXFILE $PM_INDEX
					if [ -n "$do_index_fetch" ]; then
						pm_unlink ${PM_INDEX}.bz2
						mv ${dli}/${INDEXFILE}.bz2 ${PM_INDEX}.bz2
					fi
				else
					pm_sv 'Installing new INDEX file'
					pm_install_s ${dli}/$INDEXFILE $PM_INDEX
					[ -n "$do_index_fetch" ] &&
						pm_install_s ${dli}/${INDEXFILE}.bz2 ${PM_INDEX}.bz2
				fi
				rm -rf $dli ; unset dli
			fi
			unset FETCHINDEX MASTER_SITE_INDEX do_index_fetch index_time newindex
		else
			[ -r "$PM_INDEX" ] ||
				fail "The --no-index-fetch option was used, but $PM_INDEX does not exist"
		fi
		unset INDEXFILE INDEXDIR
}

# Global: PM_INDEX_PORTS PM_INDEX
outdated_ports_from_index () {
		PM_INDEX_PORTS=$(pkg version -Ivl\< $PM_INDEX | cut -f1 -d\<)
		export PM_INDEX_PORTS

		if [ -z "$pd" -o "$pd" != /usr/ports ]; then
			PM_IPD=$(head -1 $PM_INDEX | cut -f 2 -d\|)
			PM_IPD=${PM_IPD%/*}
			PM_IPD=${PM_IPD%/*}

			[ -n "$PM_INDEX_ONLY" ] && pd=$PM_IPD
		else
			PM_IPD=$pd
		fi
		export PM_IPD
}

# Update based on options chosen above
process_options () {
	# Continue error checking in parent only
	[ -n "$PM_URB" -o -n "$UPDATE_ALL" ] && [ -n "$1" ] &&
		fail 'The -[ar] options are not compatible with other updates'

	if [ -n "$EXPUNGE" -o -n "$CLEAN_STALE" ]; then
		if [ -n "$pd" ] && pm_isdir "$pd"; then
			export pd
		else
			if [ -z "$DONT_SCRUB_DISTFILES" ]; then
				pm_v "===>>> There is no ports tree, so using -D option"
				unset ALWAYS_SCRUB_DISTFILES
				DONT_SCRUB_DISTFILES=Dopt_es; ARGS="-D $ARGS"
			fi
		fi
	else
		if [ -n "$pd" ]; then
			export pd
		elif [ -z "$LIST" -a -z "$LIST_ORIGINS" ]; then
			fail 'The value of PORTSDIR cannot be empty'
		fi
	fi

	if [ -z "$DISTDIR" -a "$PM_PACKAGES" != only -a -z "$CHECK_DEPENDS" -a \
		-z "$CHECK_PORT_DBDIR" -a -z "$LIST_ORIGINS" ]; then
		if ! DISTDIR=$(pm_make_g -V DISTDIR 2>/dev/null); then
			if ! pm_isdir "$PWD"; then
				pm_msg ''
				pm_msg "===>>> Your current working directory no longer seems to exist"
				fail 'Try: cd'
			fi
		fi
	fi

	[ -n "$DISTDIR" ] && export DISTDIR="${DISTDIR%/}/"

	[ -n "$PM_PACKAGES_BUILD" -o -n "$PM_DEL_BUILD_ONLY" ] && export PM_BUILD_ONLY_LIST=pm_bol
}
 
#=============== Begin functions relevant to --features and main ===============

# find installed port for given origin (with optional @flavor) in the pkg DB
# return values:
# 0 - package name has been printed to STDOUT
# 1 - no matching installed packages found
iport_from_origin () {
	local origin flavor pkgname_l pkgname pkgflavor

	origin=$(dir_part "$1")
	flavor=$(flavor_part "$1")

	pkgname_l=$(echo $(pkg query '%n-%v' $origin)) || return 1
	# if multiple flavors registered then fall back to $FLAVOR if no flavor has been passed in $1
	[ "${pkgname_l}" != "${pkgname_l#* }" ] && : ${flavor:=$FLAVOR}
	for pkgname in $pkgname_l; do
		pkgflavor=$(pkg annotate -Sq "$pkgname" flavor)
		if [ "$pkgflavor" = "$flavor" ]; then
			echo $pkgname
			return 0
		fi
	done
	return 1
}

# Takes default value, optional value, and message as input
# Return values:
# 0 - Default value chosen
# 1 - Optional value chosen
#
get_answer_g () {
	local default option question answer

	default=$1 ; option=$2 ; shift 2
	question="$*"

	while : ; do
		pm_msg -n "$question [${default}] "
		read answer
		pm_msg ''

		case "$answer" in
		[A-Z])
			answer=$(echo $answer | tr [:upper:] [:lower:]) ;;
		esac

		case "$answer" in
		${default}|'')
			return 0 ;;
		${option})
			return 1 ;;
		*)
			pm_msg "	===>>> $answer is not a valid response"
			pm_msg '' ;;
		esac
	done
}

# Takes a default value and message as input
# Return values:
# 0 - Answer is "Yes"
# 1 - Answer is "No"
#
get_answer_yn () {
	local default question option

	default=$1 ; shift
	question="$*"

	[ -n "$NO_ACTION" ] && return 1
	[ -n "$PM_YES" ] && return 0

	if [ "$default" = 'y' ]; then
		get_answer_g y n "$question? y/n"
	else
		! get_answer_g n y "$question? y/n"
	fi
}

# Find the new origin for moved ports
# Set global variable moved_npd on success
# Return values:
# 0 - The new origin has been stored in the global variable moved_npd
# 1 - The port has not been moved to a new origin
find_moved_port () {
	# Global: moved_npd
	local sf iport flag IFS moved reason

	sf=$(dir_part "$1")	# Search for origin without flavor
	iport="$2"		# initial package name
	flag="$3"		# optional flag "nonfatal"

	# To avoid having each word of the reason treated separately
	IFS='
'
	for moved in $(grep "^$sf|" $pd/MOVED); do
		case "$moved" in
		${sf}\|\|*)
			[ -n "$iport" ] || iport=$(iport_from_origin $sf)
			if pm_islocked $iport; then
				if [ -n "$PM_VERBOSE" ]; then
					pm_msg ''
					pm_msg "	===>>> The $sf port has been deleted"
					pm_msg "	===>>> Reason: ${moved##*|}"
					pm_msg "	===>>> Skipping it due to +IGNOREME file"
					pm_msg ''
				fi
				return 0
			else
				reason=${moved##*|}
				[ "$flag" != 'nonfatal' ] &&
					fail "The $sf port has been deleted: $reason"
			fi ;;
		${sf}\|*)
			moved_npd=${moved#*\|}	# New port directory
			moved_npd=${moved_npd%%\|*}
			pm_msg ''
			pm_msg "	===>>> The $sf port moved to $moved_npd"
			pm_msg "	===>>> Reason: ${moved##*|}"
			pm_msg ''
			find_moved_port $moved_npd ;;
		esac
	done

	if [ -z "$moved_npd" ]; then
		if [ -z "$reason" ]; then
			pm_msg ''
			pm_msg "	===>>> No $pd/$sf exists, and no information"
			pm_msg "	===>>> about $sf can be found in $pd/MOVED"
		else	# Only reached in LIST_PLUS
			pm_msg "	===>>> The $sf port has been deleted: $reason"
		fi
		pm_msg ''

		[ -n "$iport" ] || iport=$(iport_from_origin $1) || return 1
		pm_islocked $iport || return 1
	fi
	return 0
}

all_pkgs_by_origin () {
	namesorigins=$(pkg query -a "%n-%v %o")
	echo "$namesorigins"
	return
}

read_distinfos () {
	local DI_FILES iport origin distinfo s f DISCARD

	DI_FILES="$1"
	echo '############' > $DI_FILES		# Make the file > 0 bytes
	pm_msg "===>>> Gathering distinfo list for installed ports"
	pm_msg ''

	all_pkgs_by_origin | while read iport origin; do
		if ! pm_isdir_pd "$origin"; then
			find_moved_port $origin $iport nonfatal >/dev/null
			[ -n "$moved_npd" ] || continue
			origin=$moved_npd
		fi

		origin="${pd}/"$(dir_part $origin)

		if [ -s "${origin}/distinfo" ]; then
			distinfo="${origin}/distinfo"
		else
			pm_cd $origin || continue
			distinfo=$(pm_make -V DISTINFO_FILE)

			# Do not make this error fatal unless using
			# --clean-distfiles. This will prevent accidentally
			# killing other background processes when running
			# in the background itself.
			if [ -z "$distinfo" ]; then
				if [ -z "$CLEAN_DISTFILES" ]; then
					continue
				else
					fail "No DISTINFO_FILE in $origin"
				fi
			fi
		fi

		if [ -s "$distinfo" ]; then
			while read s f DISCARD; do
				case "$s" in
				SHA256)
					f=${f#(}
					echo ${f%)} >> $DI_FILES ;;
				esac
			done < $distinfo
		fi
	done

	# Tell safe_exit that we are done
	pm_unlink ${DI_FILES}-e
	sed -i -e 1s/############/%%%%%%%%%%%%/ $DI_FILES
	pm_unlink ${DI_FILES}-e
}

read_distinfos_all () {
	local DI_FILES origin distinfo s f DISCARD

	DI_FILES="$1"
	echo '############' > $DI_FILES		# Make the file > 0 bytes
	pm_msg "===>>> Gathering distinfo list for all ports"
	pm_msg '       (This will take several minutes)'
	pm_msg ''

	for origin in ${pd}/*/*; do
		case "${origin#$pd/}" in
		Mk/*|T*|distfiles/*|packages/*|*/[Mm]akefile*|CVS/*|*/CVS|base/*)
			continue ;;
		esac

		pm_isdir "$origin" ] || continue

		if [ -s "${origin}/distinfo" ]; then
			distinfo="${origin}/distinfo"
		else
			pm_cd $origin || continue
			distinfo=$(pm_make -V DISTINFO_FILE)
			[ -n "$distinfo" ] || {
				pm_msg ''
				pm_msg "===>>> No DISTINFO_FILE in $origin"
				pm_msg ''
			}
		fi

		if [ -s "$distinfo" ]; then
			while read s f DISCARD; do
				case "$s" in
				SHA256)
					f=${f#(}
					echo ${f%)} >> $DI_FILES ;;
				esac
			done < $distinfo
		fi
	done

	# Tell safe_exit that we are done
	pm_unlink ${DI_FILES}-e
	sed -i -e 1s/############/%%%%%%%%%%%%/ $DI_FILES
	pm_unlink ${DI_FILES}-e
}

# Global: roots trunks branches leaves
# Global: num_roots num_trunks num_branches num_leaves num_ports
ports_by_category () {
	pm_v "===>>> Sorting ports by category"
	roots=$(pkg    query -e "%#d = 0 && %#r = 0" "%n-%v")
	trunks=$(pkg   query -e "%#d = 0 && %#r > 0" "%n-%v")
	branches=$(pkg query -e "%#d > 0 && %#r > 0" "%n-%v")
	leaves=$(pkg   query -e "%#d > 0 && %#r = 0" "%n-%v")

	num_roots=$(echo    $(echo $roots    | wc -w))
	num_trunks=$(echo   $(echo $trunks   | wc -w))
	num_branches=$(echo $(echo $branches | wc -w))
	num_leaves=$(echo   $(echo $leaves   | wc -w))

	num_ports=$(echo $(pkg query -a "%n-%v" | wc -w))
}

# changes $PWD to $DISTDIR
delete_empty_dist_subdirs () {
	local DISTDIR="$1"

	# Get back to somewhere safe so we do not
	# delete our CWD out from under ourselves
	pm_cd $DISTDIR || fail "Cannot cd into $DISTDIR"
	find $DISTDIR -depth -mindepth 1 -type d -empty -delete
}

# Global: PM_IPD
parse_index () {
	local line origin

	origin=$(dir_part $1)
	line=$(grep -m1 "|${PM_IPD}/${origin}|" $PM_INDEX) || return 1

	case "$2" in
	name)
		echo ${line%%|*} ;;
	localbase)
		echo $line | cut -f 3 -d\| ;;
	comment)
		echo $line | cut -f 4 -d\| ;;
	descr)
		echo $line | cut -f 5 -d\| ;;
	maintainer)
		echo $line | cut -f 6 -d\| ;;
	category)
		echo $line | cut -f 7 -d\| ;;
	b-deps)
		echo $line | cut -f 8 -d\| ;;
	r-deps)
		echo $line | cut -f 9 -d\| ;;
	www)
		echo $line | cut -f 10 -d\| ;;
	esac
}

#=============== End functions relevant to --features and main ===============
#=============== Begin code relevant only to --features ===============

clean_distfiles () {
	local DI_FILES df f

	[ -n "$DISTDIR" ] || fail 'There is no DISTDIR to clean'

	# Set the file name here since we are usually called in a subshell
	DI_FILES=$(pm_mktemp DI-FILES)

	if [ -z "$PM_THOROUGH" ]; then
		read_distinfos $DI_FILES
	else
		read_distinfos_all $DI_FILES
	fi

	pm_msg "===>>> Checking for stale distfiles"
	pm_msg ''
	for df in $(find $DISTDIR -type f | sort); do
		f=${df#$DISTDIR}
		if ! grep -ql ^$f $DI_FILES; then
			if get_answer_yn n "\t===>>> Delete stale file: $f"; then
				pm_msg "       Deleting $f" ;
				pm_msg ''
				pm_unlink $df
			fi
		fi
	done

	delete_empty_dist_subdirs $DISTDIR
	pm_unlink $DI_FILES
}

clean_packages () {
	local package pkg_dir port_ver link empty_dirs

	init_packages_var

	pm_msg "===>>> Checking for stale packages"
	for package in $(find $PACKAGES -type f | sort); do
		pkg_dir=${package##*/} ; pkg_dir=${pkg_dir%\.*}
		pm_msg ''

		origin=$(pkg query -F $package "%o" 2>/dev/null) ||
			origin=$(tar -O -zxvf $package '+CONTENTS' 2>/dev/null | grep '@comment ORIGIN:') ||
			origin=$(tar -O -zxvf $package '+MANIFEST' 2>/dev/null | grep '^origin:') ||
			fail "Empty origin in $package"
		origin=${origin#@comment ORIGIN:}
		origin=${origin#origin: }

		if [ -z "$PM_INDEX" ]; then
			if pm_isdir_pd "$origin"; then
				pm_cd $pd/$origin && port_ver=$(pm_make -V PKGNAME)
				[ -n "$port_ver" ] || fail "Is $pd/$origin/Makefile missing?"
			else
				pm_msg "===>>> The origin for ${package##*/} ($origin) is missing"
			fi
		else
			if ! port_ver=$(parse_index $origin name); then
				pm_msg "===>>> Cannot determine latest version of ${package##*/} from $PM_INDEX"
			fi
		fi

		if [ -n "$port_ver" ]; then
			if [ "$port_ver" = "$pkg_dir" ]; then
				pm_msg "===>>> ${package##*/} is up to date"
				if ! pkg info -e $pkg_dir; then
					pm_msg "	===>>> $pkg_dir is not installed"
					pm_msg "	===>>> Path: ${package}"
					get_answer_yn y "\n\t===>>> Delete stale package: ${package##*/}" && {
						pm_msg "	===>>> Deleting $package"
						pm_unlink_s $package
					}
				fi
				unset port_ver
				continue
			fi

			pm_msg "===>>> Package version: $pkg_dir"
			pm_msg "       Latest version:  $port_ver"

			unset port_ver

			if pkg info -e $pkg_dir; then
				pm_msg "	===>>> ${package##*/} matches the installed version"
			else
				pm_msg "	===>>> ${package##*/} is not installed"
			fi
		fi

		pm_msg "	===>>> Path: ${package}"

		get_answer_yn n "\n\t===>>> Delete stale package: ${package##*/}" && {
			pm_msg "	===>>> Deleting $package"
			pm_unlink_s $package
		}
	done
	pm_msg ''
	pm_msg ''

	pm_msg "===>>> Deleting stale symlinks"
	pm_cd $PACKAGES || fail "Cannot cd to $PACKAGES"
	for link in $(find . -type l | sort) ; do
		if [ ! -e "$link" ]; then
			pm_msg "	===>>> ${link#./}"
			pm_unlink_s $link
		fi
	done
	pm_msg ''
	pm_msg ''

	empty_dirs=$(find . -type d -empty -print | sort)
	case "$empty_dirs" in
	\.|'')
		pm_msg "===>>> No empty directories in $PACKAGES" ;;
	*)
		pm_msg "===>>> Deleting empty directories"
		for dir in $empty_dirs; do
			pm_msg "	===>>> ${dir#\.\/}"
		done
		pm_find_s . -type d -empty -delete ;;
	esac
	pm_msg ''
}

check_port_dbdir () {
	pm_isdir "$port_dbdir" ||
		fail 'PORT_DBDIR is empty, or the directory $port_dbdir does not exist'

	unique_list=':'

	pm_msg "===>>> Building list of installed port names"
	pm_msg ''
	while read pkg origin; do
		if ! pm_isdir_pd "$origin"; then
			find_moved_port $origin $pkg nonfatal >/dev/null
			[ -n "$moved_npd" ] || continue
			origin=$moved_npd
		fi

		if ! pm_cd $pd/$origin; then
			pm_msg "	===>>> $pd/$origin does not exist for $pkg"
			continue
		fi
		unique_list="${unique_list}$(make -V UNIQUENAME -V OPTIONS_NAME | tr '\n' ':')"
	done <<-EOF
	$(all_pkgs_by_origin)
	EOF

	pm_msg "===>>> Checking $port_dbdir"

	[ -n "$PM_VERBOSE" ] && {
		print='-print'
		pm_msg '';
		pm_msg "===>>> Deleting empty directories (if any)";
	}
	pm_find_s $port_dbdir -type d -empty $print -delete >&2
	pm_v

	for dir in ${port_dbdir}/*; do
		dbdir=${dir#$port_dbdir/}

		[ -n "$PM_VERBOSE" ] && pm_msg -n "===>>> Checking ${dbdir}: "
		case "$unique_list" in
		*:${dbdir}:*)
			pm_v "Ok" ;;
		*)
			pm_v
			pm_msg "	===>>> $dbdir does not seem to be installed"
			get_answer_yn n "\n\t===>>> Delete ${dir}"
			[ "$?" -eq 0 ] && pm_rm_s -rf $dir
			pm_msg '' ;;
		esac
	done
}

#=============== End code relevant only to --features ===============
#=============== Begin functions for getopts features and main ===============

check_state () {
	# Global: state
	local state_set

	if egrep -ql '^(FORBIDDEN|BROKEN|IGNORE)' Makefile; then
		for state in FORBIDDEN BROKEN IGNORE; do
			state_set=$(pm_make -V $state)
			if [ -n "$state_set" ]; then
				pm_msg "	===>>> This port is marked $state"
				pm_msg -e "\t===>>> $state_set\n\n"
				return 1
			fi
		done
	fi
	return 0
}

# Takes $iport and $origin as arguments
#
check_force_multi () {
	if [ -n "$PM_FORCE" ]; then
		check_restart_and_udf $1 || return 1
	elif [ -n "$PM_URB_UP" ]; then
		case " $PM_URB_LIST " in
		*" $1 "*)
			check_restart_and_udf $1 || return 1 ;;
		esac
	elif [ -n "$PM_MULTI_PORTS" ]; then
		case "$PM_MULTI_PORTS" in
		*:${1}:*|*:${2}:*)
			return 1 ;;
		esac
	fi
}

find_new_port () {
	# Global: new_port
	local portdir flavor flavor_option

	[ -n "$new_port" ] && return

	portdir=$(dir_part "$1")
	flavor=$(flavor_part "$1")
	flavor_option=${flavor:+FLAVOR=$flavor}
#	export_flavor $flavor
	if pm_cd_pd $portdir; then
		new_port=$(pm_make -V PKGNAME ${flavor_option})
	else
		new_port=$(parse_index $portdir name) ||
			fail "No entry for $portdir in $PM_INDEX"
	fi
}

check_for_updates () {
	# Global: num_updates
	local nf iport originflavor flavor origin port_ver do_update skip

	[ "$1" = 'list' -o "$1" = 'multi' ] && { nf=nonfatal; shift; }

	iport=$1
	originflavor=${2:-$(origin_from_pdb $iport)} || return 0
	flavor=$(flavor_part "$originflavor")
	export_flavor $flavor
	flavor_option=${flavor:+FLAVOR=$flavor}
	origin=$(dir_part "$originflavor")

	if [ -n "$PM_INDEX" ]; then
		case "$PM_INDEX_PORTS" in
		*${iport}*)
			port_ver=$(parse_index $origin name) ||
				fail "No entry for $origin in $PM_INDEX"
			do_update=upd_idx ;;
		esac

		[ -z "$do_update" -a -z "$LIST_PLUS" ] && {
			check_force_multi $iport $originflavor || do_update=upd_fm_idx; }

		if [ -z "$do_update" -a -n "$PM_INDEX_ONLY" -a -n "$PM_THOROUGH" ]; then
			port_ver=$(parse_index $origin name) || {
				pm_msg "	===>>> $pd/$origin does not exist in $PM_INDEX";
				pm_msg "	===>>> This port should probably be updated"; }
		else
			[ -n "$PM_INDEX_FIRST" ] || skip=index_skip
		fi
	fi

	if [ -z "$do_update" -a -z "$skip" -a -z "$PM_INDEX_ONLY" ] && pm_isdir "$pd/$origin"; then
		if ! pm_cd $pd/$origin; then
			if pm_islocked "$iport"; then
				pm_msg "	===>>> Warning: Unable to cd to $pd/$origin"
				pm_msg "	===>>> Continuing due to $pdb/$iport/+IGNOREME"
				pm_msg ''
				CUR_DEPS="${CUR_DEPS}${iport}:${originflavor}:"
				return 0
			else
				fail "Cannot cd to port directory: $pd/$origin"
			fi
		fi
		port_ver=$(pm_make $flavor_option -V PKGNAME)
		[ -z "$port_ver" ] && fail "Is $pd/$origin/Makefile missing?"
	elif [ -z "$do_update" -a -z "$skip" -a -z "$PM_INDEX_ONLY" ]; then
		find_moved_port $origin $iport $nf

		# If the port has moved and no +IGNOREME, we have to update it
		if [ -n "$moved_npd" ]; then
			if pm_islocked "$iport"; then
				pm_msg "	===>>> Continuing due to $pdb/$iport/+IGNOREME"
				pm_msg ''
				CUR_DEPS="${CUR_DEPS}${iport}:${originflavor}:"
				return 0
			else
				do_update=do_update_moved
				new_port=""
				find_new_port "$moved_npd" && port_ver=$new_port
			fi
		fi
	fi

	if [ -z "$do_update" -a -n "$port_ver" ]; then
		if [ "$iport" = "$port_ver" ]; then
			if [ -n "$LIST_PLUS" -a -z "$PM_INDEX_ONLY" ]; then
				check_state
				return 0
			elif [ -n "$LIST" ]; then
				return 0
			else
				check_force_multi $iport $originflavor || do_update=upd_fm_eq
				unset port_ver
			fi
		else
			case $(pkg version -t $iport $port_ver) in
			\<)
				do_update=upd_lt ;;
			=)
				;;	# Can be reached if same version with different options
			\>)
				if [ -n "$PM_VERBOSE" ]; then
					pm_msg "	===>>> Port version $port_ver does not"
					pm_msg "	===>>> seem newer than installed $iport"
				fi ;;
			*)
				fail "pkg version -t $iport $port_ver gave an unexpected result" ;;
			esac

			[ -z "$do_update" ] && {
				check_force_multi $iport $originflavor || do_update=upd_fm_ne; }
		fi
	fi

	if [ -z "$do_update" ]; then
		[ -z "$LIST_PLUS" ] && CUR_DEPS="${CUR_DEPS}${iport}:${originflavor}:"
		return 0
	fi

	if [ -n "$LIST_PLUS" ]; then
		if [ -z "$moved_npd" ]; then
			pm_msg "	===>>> New version available: $port_ver"
			if pm_islocked "$iport"; then
				pm_msg "	===>>> +IGNOREME file is present for $1"
			fi
			pm_cd_pd $origin && check_state
			num_updates=$(( $num_updates + 1 ))
		else
			unset moved_npd
		fi
		return 0
	elif [ -n "$PM_UPDATE_IF_NEWER" ]; then
		return 1
	fi

	# No need for check_exclude here because it is already
	# run in the places that call check_for_updates().
	check_interactive $iport $port_ver || return 0
	update_port $iport $port_ver || return 1
	return 0
}

pm_pkg_create () {
	local pkgdir pkgname portdir format backup

	pkgdir="$1"
	pkgname="$2"
	portdir="$3"
	format="${4:-txz}"
	init_pbu_var

	if [ "$pkgdir" = "$PACKAGES" ]; then
		for pkgdir in All Latest ${portdir%/*}; do
			pm_mkdir_s ${PACKAGES}/${pkgdir} ||
				fail "Cannot mkdir -p ${PACKAGES}/${pkgdir}"
		done
		pkgdir=${PACKAGES}/All
		pm_msg "===>>> Creating a package for new version $2"
	else
		pm_msg ''
		pm_msg "===>>> Creating a backup package for old version $2"
		backup=backup
		[ -n "$BACKUP_FORMAT" ] && format=$BACKUP_FORMAT
	fi

	pm_cd $pkgdir || fail "Cannot cd into $pkgdir to create a package"
	if $PM_SU_CMD pkg create -f $format $pkgname; then
		if [ "$pkgdir" = "$pbu" ]; then
			if [ -n "$BACKUP" ]; then
				pm_msg "===>>> Package saved to $pkgdir"
				pm_msg ''
			else
				NB_DELETE="${NB_DELETE}"$(echo $pkgname.*)" "
			fi
		elif [ "$pkgdir" = "$PACKAGES/All" ]; then
			local pkg ; pkg=${pkgname}.$format

			if [ -z "$PM_INDEX_ONLY" ]; then
				local pkg_latest_file

				pm_cd_pd $portdir
				pkg_latest_file=$(pm_make -V PKGLATESTFILE) # <se> may not be compatible with $format!!!
				$PM_SU_CMD install -lr $pkgdir/$pkg ${pkg_latest_file}
			fi

			cd ${pkgdir%/*}/${portdir%/*}
			$PM_SU_CMD install -lr $pkgdir/$pkg $pkg
			pm_msg "  ===>>> Package saved to $pkgdir"
			pm_msg ''
		fi
	else
		local answer

		while : ; do
			pm_msg -e "\n===>>> Package creation failed for $pkgname!\n"

			[ -n "$backup" -a -n "$PM_IGNORE_FAILED_BACKUP_PACKAGE" ] && return

			pm_msg "===>>> Ignore this error  [i]"
			pm_msg "===>>> Abort update       [a]"
			pm_msg "===>>> Retry              [r]"
			pm_msg -e "\n===>>> How would you like to proceed? [i] \c"
			read answer
			pm_msg ''

			case "$answer" in
			''|[iI])
				break ;;
			[aA])
				fail "Package creation failed for $pkgname" ;;
			[rR])
				pm_pkg_create $* ; break ;;
			*)
				pm_msg "	===>>> $answer is not a valid response" ;;
			esac
		done
	fi
}

dist_list_filename () {
	local portdir upg_port dist_list

	portdir="$1"
	upg_port="$2"

	if [ -s "${pdb}/${upg_port}/distfiles" ]; then
		dist_list="${pdb}/${upg_port}/distfiles"
	else
		# Old method, for now
		if pm_cd $pd/$portdir; then
			dist_list=$(pm_make_b -V OPTIONS_FILE)
			dist_list="${dist_list%options}distfiles"
		else
			# The port might have moved, etc.; so take a stab at it,
			# but do not take a chance with a possibly wrong answer
			dist_list="$port_dbdir/$(tr "/" "_" ${portdir#$pd/})/distfiles"
		fi
	fi
	[ -s "$dist_list" ] && echo "$dist_list"
}

# Changes PWD
# Global: dist_list dist_list_files pdb
find_dl_distfiles () {
	local origin upg_port dist_list

	portdir="$1"
	upg_port="$2"
	# We need to define these for use in the deletion/update process.

	dist_list=$(dist_list_filename $portdir $upg_port)
	[ -z "$distlist" ] && return
	
	[ -n "$DONT_SCRUB_DISTFILES" ] && return 0

	local line
	while read line; do
		case "$line" in
		DISTFILE*)
			line=${line#DISTFILE:} ; line=${line%%:*}
			dist_list_files="${dist_list_files}${line#*/} " ;;
		esac
	done < $dist_list

	# Clean up after the old method
	case "$dist_list" in
	${port_dbdir}*)
		pm_sv Deleting $dist_list
		pm_unlink_s $dist_list

		local dir=$(find ${dist_list%/distfiles} -type d -empty 2>/dev/null)
		if pm_isdir "$dir"; then
			pm_sv Deleting empty $dir directory
			pm_rmdir_s $dir
		fi
	esac
}

check_di_files () {
	# Global: distfiles_checked

	if [ -s "$DI_FILES" ]; then
		if grep -ql ^${port_subdir}${1} $DI_FILES; then
			distfiles_checked="${distfiles_checked}${1}:"
			pm_v "===>>> Keeping distfile, valid for another port: $1"
			return 0
		fi
	fi

	return 1
}

find_and_delete_distfiles () {
	# Global: distfiles_checked
	local file answer

	for file in ${1}*; do
		# This generally means the pattern did not match
		case "$file" in
		*\*)
			[ "$1" = "${1%[_-]*}" ] && return 0
			# This will happen for files like foo-bar_baz-1.23
			find_and_delete_distfiles ${1%[_-]*} ;;
		esac

		case "$distfiles_checked" in
		*:${file}:*)
			continue ;;
		esac
		[ -f "$file" ] || continue

		case "$distfiles" in
		*" ${file} "*)
			distfiles_checked="${distfiles_checked}${file}:"
			pm_v "===>>> Keeping current distfile: ${port_subdir}${file}"
			continue ;;	# Do not delete current version
		*)	check_di_files $file && continue

			if [ -n "$ALWAYS_SCRUB_DISTFILES" -o -n "$delete_all" ]; then
				pm_msg "===>>> Deleting stale distfile: ${port_subdir}${file}"
				pm_unlink $file
			else
				if get_answer_yn n "\n===>>> Delete ${port_subdir}${file} && ? y/n"; then
					pm_unlink $file
				else
					distfiles_checked="${distfiles_checked}${file}:"
				fi
			fi ;;
		esac
	done
}

make_distfiles () {
	local portdir=$(dir_part "$1")

	pm_make -C $pd/$portdir -V ALLFILES
}

# Global: port_subdir full_port_subdir
make_port_subdir () {
	local portdir port_subdir

	portdir="$1"
	port_subdir=$(pm_make -C "$pd/$portdir" -V DIST_SUBDIR)
	echo ${port_subdir:+${port_subdir}/}
}

# Global: distfiles dist_list_files full_port_subdir DISTDIR
set_distfiles_and_subdir () {
	local portdir upg_port port_subdir full_port_subdir

	portdir="$1"
	upg_port="$2"

	[ -z "$dist_list_files" ] && find_dl_distfiles $portdir $upg_port

        pm_isdir_pd "$portdir" || return 1
	pm_cd_pd $portdir

	[ -n "$distfiles" ] || distfiles=$(make_distfiles $portdir)

	# Ports may have no distfiles
	[ -z "$dist_list_files" -a -z "$distfiles" ] && return 2

	port_subdir=$(make_port_subdir $portdir)
	full_port_subdir="${DISTDIR}${port_subdir}"

	if pm_isdir "$full_port_subdir"; then
		pm_cd $full_port_subdir || fail "cd to $full_port_subdir failed!"
	else
		pm_msg ''
		pm_msg "===>>> $full_port_subdir does not exist, therefore we"
		pm_msg '       will assume that all relevant distfiles are gone.'
		pm_msg ''
		pm_msg "       Try $progname [-y] --clean-distfiles for a full cleanup"
		pm_msg ''
		return 3
	fi
	return 0
}

# Global: distfiles_checked port_subdir
delete_stale_distfiles () {
	local portdir upg_port file answer

	portdir="$1"
	upg_port="$2"
	[ -n "$DISTDIR" ] || return # DISTDIR not set because of PM_PACKAGES

	set_distfiles_and_subdir $portdir $upg_port || return 0
	distfiles_checked=':'
set -x
	# If these two match, it means that the distfiles in the
	# file are the current set, so do not delete them.
	if [ ! " $dist_list_files" = "$distfiles" ]; then
		for file in $dist_list_files; do
			[ -f "$file" ] || continue

			case "$distfiles" in
			*" ${file} "*)
				distfiles_checked="${distfiles_checked}${file}:"
				pm_v "===>>> Keeping current distfile: ${port_subdir}${file}"
				continue ;;	# Do not delete current version
			esac

			check_di_files $file && continue

			if [ -n "$ALWAYS_SCRUB_DISTFILES" -o -n "$delete_all" ]; then
				pm_msg "===>>> Deleting stale distfile: ${port_subdir}${file}"
				pm_unlink $file
			else
				if get_answer_yn n "\n===>>> Delete ${port_subdir}${file}"; then
					pm_unlink $file
				else
					distfiles_checked="${distfiles_checked}${file}:"
				fi
			fi
		done
	fi

	# Eventually we will hide this behind an "aggressive distfile purge"
	# flag, but until the DISTFILE stuff is well populated
	# keep doing it both ways.
	for file in $distfiles $dist_list_files; do
		find_and_delete_distfiles ${file%[-]*}-[0-9]
	done
set +x
	pm_v "===>>> Distfile cleaning complete\n"
}

# Global: delete_all DISTDIR
delete_all_distfiles () {
	[ -n "$DISTDIR" ] || return # DISTDIR not set because of PM_PACKAGES
	local origin rc delete_current

	# In case we are called more than once
	unset delete_all dist_list dist_list_files
	origin="$1"

	set_distfiles_and_subdir $origin $upg_port ; rc=$?
	case "$rc" in
	1)
		pm_msg ''
		pm_msg "===>>> No $pd/$origin exists to find the distfile list"
		pm_msg "       Try $progname [-y] --clean-distfiles for a full cleanup"
		pm_msg ''
		if [ -n "$dist_list_files" ]; then
			local answer f

			# <se>
			answer=y
			if [ -z "$ALWAYS_SCRUB_DISTFILES" ]; then
				pm_msg "===>>> However, the list of files from $dist_list"
				get_answer_yn n "       should be current.  Delete the files on this list"
				[ "$?" -eq 1 ] && answer=n
			fi

			case "$answer" in
			y)	for f in $dist_list_files; do
					if [ -f "$f" ]; then
						pm_msg "       Deleting ${port_subdir}${f}"
						pm_unlink $f
					fi
				done ;;
			esac
		fi
		return 0 ;;
	2)
		pm_msg "===>>> This port has no distfiles"
		return 0 ;;
	3)
		return 0 ;;	# port_subdir does not exist
	esac

	if [ -n "$ALWAYS_SCRUB_DISTFILES" ]; then
		pm_msg "===>>> Deleting all distfiles for $origin"
		delete_all=delete_all
	else
		pm_msg "===>>> Delete old and new distfiles for $origin"
		if get_answer_yn n "       without prompting"; then
			delete_all=delete_all2
		else
			get_answer_yn n "===>>> Delete the current distfiles" &&
				delete_current=delete_current
		fi
	fi

	if [ -n "$delete_all" -o -n "$delete_current" ]; then
		# Doing this now means less work in delete_stale()
		[ -n "$distfiles" ] && eval rm -f $distfiles
	fi
	delete_stale_distfiles $origin $upg_port
	delete_empty_dist_subdirs $DISTDIR
}

#=============== End functions for getopts features and main ===============
#=============== Begin code relevant only to getopts features ===============

list_ports () {
	ports_by_category ; pm_v
	num_updates=0

	pm_msg "===>>> Root ports (No dependencies, not depended on)"
	for iport in $roots; do
		pm_msg "===>>> $iport"
		[ -n "$LIST_PLUS" ] && check_for_updates list $iport
	done
	pm_msg "===>>> $num_roots root ports"
	pm_msg ''
	pm_msg "===>>> Trunk ports (No dependencies, are depended on)"
	for iport in $trunks; do
		pm_msg "===>>> $iport"
		[ -n "$LIST_PLUS" ] && check_for_updates list $iport
	done
	pm_msg "===>>> $num_trunks trunk ports"
	pm_msg ''
	pm_msg "===>>> Branch ports (Have dependencies, are depended on)"
	for iport in $branches; do
		pm_msg "===>>> $iport"
		[ -n "$LIST_PLUS" ] && check_for_updates list $iport
	done
	pm_msg "===>>> $num_branches branch ports"
	pm_msg ''
	pm_msg "===>>> Leaf ports (Have dependencies, not depended on)"
	for iport in $leaves; do
		pm_msg "===>>> $iport"
		[ -n "$LIST_PLUS" ] && check_for_updates list $iport
	done
	pm_msg "===>>> $num_leaves leaf ports"
	pm_msg ''
	pm_msg "===>>> $num_ports total installed ports"

	if [ "$num_updates" -gt 1 ]; then
		pm_msg "	===>>> $num_updates have new versions available"
	elif [ "$num_updates" -eq 1 ]; then
		pm_msg "	===>>> 1 has a new version available"
	elif [ -n "$LIST_PLUS" ]; then
		pm_msg "	===>>> There are no new versions available"
	fi
}

# Global: EXPUNGE pdb glob_dirs pbu ARGS
expunge () {
	local origin deplist f glob_dirs

	if ! pm_isdir "$pdb/$EXPUNGE" || ! pkg info -e $EXPUNGE; then
		glob_dirs=$(find_glob_dirs $EXPUNGE)
		case $? in
		1)
			fail "No such port: $EXPUNGE" ;;
		2)
			pm_msg "===>>> $EXPUNGE matched multiple ports"
			fail "The -e option works with only one port at a time" ;;
		esac

		EXPUNGE=${glob_dirs#$pdb/}
	fi

	origin=$(origin_from_pdb $EXPUNGE)
	deplist=$(pkg query "%rn-%rv" $origin)
	if [ -n "$deplist" ]; then
		pm_msg "===>>> Warning: Ports with dependencies on ${EXPUNGE}:"
		pm_msg "$deplist" | sed 's/^/	/'
		get_answer_yn n "\n\t===>>> Delete this dependency data" || exit 1
		exit 1 #TODO
#		for f in $deplist; do
#			update_contents delete $f $origin
#		done
	fi

	[ -n "$BACKUP" ] && { init_pbu_var ; pm_pkg_create $pbu $EXPUNGE; }
	[ -z "$DONT_SCRUB_DISTFILES" ] && delete_all_distfiles $origin

	pm_msg "===>>> Running pkg delete -f $EXPUNGE"
	pm_pkg_delete_s $EXPUNGE || fail "pkg delete failed"

	pm_msg ''
	pm_msg "===>>> Cleaning stale ports (no longer depended on)"
	clean_stale
}

# Global: no_del_list
clean_stale () {
	local no_del_list check_needed stale_ports file iport origin deplist dep

	no_del_list=' '
	not_done=1
	while [ $not_done -eq 1 ]; do
		not_done=0
		stale_ports=$(pkg query -ae '%a = 1' '%?r %n-%v' | awk '/^0 / { print \$2 }')
		for file in $stale_ports; do
			iport=${file%/+REQUIRED_BY}
			iport=${iport#$pdb/}

			case "$no_del_list" in
			*" ${iport} "*)
				continue ;;
			esac

			origin=$(origin_from_pdb $iport)
			deplist=""
			if [ -n "$deplist" ]; then
				pm_msg ''
				pm_msg "===>>> Warning: Unrecorded dependencies on ${iport}:"
				for dep in $deplist; do
					dep=${dep%/+CON*}
					pm_msg "	${dep##*/}"
				done
				pm_msg ''
				pm_msg "===>>> Try $progname --check-depends"
				pm_msg ''
				continue
			fi

			pm_msg ''
			pkg info -f $iport >&2

			if get_answer_yn n "\t===>>> ${iport} is no longer depended on, delete"; then
				if [ -n "$BACKUP" ]; then
					init_pbu_var
					pm_pkg_create $pbu $iport $portdir
				fi
				[ -z "$DONT_SCRUB_DISTFILES" ] && delete_all_distfiles $origin

				pm_msg "===>>> Running pkg delete -f $iport"
				pm_pkg_delete_s $iport || fail "pkg delete failed"
				not_done=1
			else
				no_del_list="${no_del_list}${iport} "
			fi
		done
	done
}

#=============== Begin functions for main ===============

already_done () {
	pm_msg "===>>> The update for $1 is already done"
	pm_msg ''
}

check_restart_and_udf () {
	# RESTART will usually be empty, and we don't want
	# to go out to the disk if we don't have to.
	[ -z "$RESTART" ] && return 1

	if [ ! -e "$pdb/${1}/PM_UPGRADE_DONE_FLAG" ] || ! pkg info -e $1; then
		return 1
	else
		already_done $1
	fi
}

check_interactive () {
	[ -n "$INTERACTIVE_UPDATE" ] || return 0

	local update_to default_answer

	[ -n "$2" ] && update_to=" to $2"

	case "$INTERACTIVE_YES" in
	*:${1}:*)
		return 0 ;;
	esac

	case "$INTERACTIVE_NO" in
	*:${1}:*)
		return 1 ;;
	esac

	if pm_islocked $1; then
		pm_msg ''
		pm_msg "===>>> package is locked or +IGNOREME file is present for $1"
		pm_msg ''
		default_answer="n"
	else
		default_answer="y"
	fi

	if get_answer_yn n "===>>> Update ${1}${update_to}"; then
		INTERACTIVE_YES="${INTERACTIVE_YES}${1}:"
	else
		INTERACTIVE_NO="${INTERACTIVE_NO}${1}:"
		return 1
	fi
}

check_exclude () {
	[ -n "$PM_EXCL" ] || return 0

	local pat

	for pat in $PM_EXCL; do
		case "$1" in
		*${pat}*)
			if [ -n "$PM_VERBOSE" ]; then
				pm_msg "===>>> Skipping $1"
				pm_msg "       because it matches the pattern: *${pat}*"
				pm_msg ''
			fi
			return 1 ;;
		esac
	done

	return 0
}

check_fetch_only () {
	local type=${1:-Distfile} count nf fetches

	[ -n "$FETCH_ONLY" ] || return 0
	[ -z "$distfile" -a -n "$PM_PACKAGES" ] && return 0

	pm_msg ''
	count=0
	while nf=$(pm_lstemp fetchlog | wc -l) && [ $nf -gt 0 ]; do
		[ $nf -gt 1 ] && fetches=fetches || fetches=fetch
		count=$(( $count + 1 ))
		if [ $count -eq 1 ]; then
			pm_msg "===>>> Waiting for $nf distfile $fetches to finish"
		elif [ $count -eq 3 ]; then
			count=0
		fi
		sleep 2
	done
	pm_msg "===>>> $type fetching is complete"
	FETCH_ONLY_DONE=fetch_only_done
	safe_exit
}

term_printf () {
	case "$1" in
	'')
		[ -n "$PM_MULTI_PORTS" ] && pm_msg -e "\n===>>> ${PM_PARENT_PORT}" ;;
	*\>\>*)
		pm_msg -e "\n===>>> ${PM_PARENT_PORT}${1}" ;;
	esac

	[ -n "$PM_NO_TERM_TITLE" ] && return
	case "$TERM" in
	cons*)
		return ;;
	esac

	printf "\033]0;$progname: ${PM_PARENT_PORT}${1}\007"
}

update_pm_nu () {
	case "$PM_NEEDS_UPDATE" in
	*\ $1\ *)
		return ;;
	esac

	PM_NEEDS_UPDATE="${PM_NEEDS_UPDATE}${1} "
}

update_build_l () {
	local originflavor origin flavor iport

	originflavor=$1 ; update_pm_nu $originflavor
	origin=$(dir_part "$originflavor")
	flavor=$(flavor_part "$originflavor")
	iport="$2"

	[ -n "$PM_NO_CONFIRM" ] && return

	if [ -z "$iport" ]; then
		case "$build_l" in
		*\ $origin\\*)
			return ;;
		esac
		build_l="${build_l}\tInstall $originflavor\n"
		return
	else
		case "$build_l" in
		*\ $iport\ *|*\ $iport\\*)
			return ;;
		esac
	fi

	find_new_port "$originflavor" # sets global variable new_port

	case $(pkg version -t $iport $new_port 2>/dev/null) in
	\<)
		build_l="${build_l}\tUpgrade $iport to $new_port\n" ;;
	=)
		build_l="${build_l}\tRe-install $iport\n" ;;
	\>)
		build_l="${build_l}\tDowngrade $iport to $new_port\n" ;;
	*)
		build_l="${build_l}\tUpgrade $iport\n" ;;
	esac
}

update_port () {
	local deps

	if [ -n "$2" ]; then
		pm_msg "===>>> Launching child to update $1 to $2"
	else
		if [ -z "$FETCH_ONLY" ]; then
			case "$1" in
			*/*)
				pm_msg "===>>> Launching child to install ${1#$pd/}" ;;
			*)
				pm_msg "===>>> Launching child to reinstall $1" ;;
			esac
		else
			if [ "$PM_PACKAGES" != 'only' ]; then
				pm_msg "===>>> Launching child to check distfiles for $1"
			else
				pm_msg "===>>> Launching child to check package files for $1"
			fi
		fi
	fi

	dep_of_deps=$(( $dep_of_deps + 1 ))

	[ -n "$PM_FIRST_PASS" ] && [ ! \( -n "$PM_FORCE" -a -n "$PM_ALL_FETCH" \) ] &&
		num_of_deps=$(( $num_of_deps + 1 ))

	deps="(${dep_of_deps}/${num_of_deps})"

	term_printf " ${PM_DEPTH#* }>> ${1#$pd/} ${deps}"

	[ -n "$doing_dep_check" -o \( -n "$UPDATE_ALL" -a -n "$PM_FIRST_PASS" \) ] &&
		unset NO_DEP_UPDATES

	if [ -z "$NO_ACTION" -o -n "$PM_FIRST_PASS" ]; then
		("$program" $ARGS $*) || update_failed=update_failed
		. $IPC_SAVE && > $IPC_SAVE
		[ -n "$update_failed" ] && fail "Update for $1 failed"
	else
		pm_v "===>>> Build canceled due to -n flag"
	fi

	if [ -n "$UPDATE_ALL" ]; then
		# Fix terminal titlebar in case of a long delay between ports to update
		term_printf " (${num_of_deps})"
		pm_msg -e "===>>> Returning to update check of installed ports\n"
	elif [ -n "$PM_URB" ]; then
		return 0
	elif [ -n "$PM_FIRST_PASS" -a -z "$PM_PACKAGES" ]; then
		pm_msg "===>>> Continuing initial dependency check for $portdir"
	else
		term_printf " ${PM_DEPTH#* }${deps}"
		pm_msg -e  "\n===>>> Returning to dependency check for $portdir"
	fi
	return 0
} # update_port()

# remove duplicate words from parameters passed
# prints concatenation of unique words with blank characters at front and end
uniquify_list () {
	local ul_item ul_temp_list

	for ul_item in "$@"; do
		case "$ul_temp_list" in
		*" $ul_item "*)
			;;
		*)
			ul_temp_list="$ul_temp_list $ul_item " ;;
		esac
	done

	echo $ul_temp_list
}

# remove passed run dependency list items from global build-only dependency list
# Global: build_only_dl_g
clean_build_only_list () {
	local run_depends dep temp_bodlg

	run_depends=" $* "		# blanks at end for case condition
	for dep in $build_only_dl_g; do
		case "$run_depends" in
		*" ${dep} "*)
			;;
		*)
			temp_bodlg="$temp_bodlg $dep" ;;
		esac
	done

	build_only_dl_g=" $(uniquify_list $temp_bodlg) "
}

# print dependency list for dependency types passed as parameter from port makefile
gen_make_dep_list () {
	local portdir depend_types type var_opt

	portdir="$1"; shift
	depend_types="$*"

	export_flavor $(flavor_part $portdir)
	portdir=$(dir_part $port_dir)

	for type in $*; do
		case $type in
		all-depends-list)
			var_opt="$var_opt -V RUN_DEPENDS" ;& 	# fall through ...
		build-depends-list)
			var_opt="$var_opt -V PKG_DEPENDS -V EXTRACT_DEPENDS \
				-V PATCH_DEPENDS -V FETCH_DEPENDS -V BUILD_DEPENDS -V LIB_DEPENDS";;
		run-depends-list)
			var_opt="$var_opt -V RUN_DEPENDS -V LIB_DEPENDS" ;;
		test-depends-list)
			var_opt="$var_opt -V TEST_DEPENDS" ;;
		*)
			fail "gen_make_dep_list: Unsupported option '$type'" ;;
		esac
	done
	[ -n "$var_opt" ] && make -C "$pd/$portdir" $var_opt | tr ' ' '\n' | cut -d: -f2 | sort -u
}

# print dependency list for dependency types passed as parameter from INDEX
gen_index_dep_list () {
	local portdir dep_type var_opt temp_list item list

	portdir="$1"; shift
	depend_types="$*"

	case "$depend_types" in
	'build-depends-list run-depends-list'|all-depends-list)
		temp_list="$(parse_index $portdir b-deps) $(parse_index $portdir r-deps)" ;;
	build-depends-list)
		temp_list=$(parse_index $portdir b-deps) ;;
	run-depends-list)
		temp_list=$(parse_index $portdir r-deps) ;;
	esac

	temp_list=$(uniquify_list $temp_list)

	for item in $temp_list ; do
		list="$list $(grep -m1 ^${item}\| $PM_INDEX | cut -f 2 -d \|)"
	done

	pm_msg $list
}

# print dependency list 
gen_dep_list () {
	if [ -z "$PM_INDEX_ONLY" ]; then
		gen_make_dep_list "$@"
	else
		gen_index_dep_list "$@"
	fi
}

# Global: d_port
check_conflicts () {
	local portdir="$1"
	local origin="$2"

	local dir=$(dir_part $d_port)
	local flavor=$(flavor_part $d_port)
	local flavor_opt=${flavor:+FLAVOR=$flavor}
	local conflicts

	if pm_cd "$pd/$dir"; then
		if grep -ql ^CONFLICTS Makefile ; then
			conflicts=$(pm_make_b $flavor_opt -V CONFLICTS -V CONFLICTS_BUILD -V CONFLICTS_INSTALL)
		fi
	else
		fail "Cannot cd to $dir"
	fi

	local glob
	for glob in $conflicts; do
		local confl_p=$(pkg query -g "%n-%v" $glob 2>/dev/null)
		if [ -n "$confl_p" ]; then
			confl_p=${confl_p%% *}
			d_port="$pd/$(origin_from_pdb $confl_p)"
			if [ "${d_port#$pd/}" = "$portdir" ]; then
				pm_msg -e "\n===>>> $origin seems to depend on $portdir"
				pm_msg '       which looks like a dependency loop'
				fail "Try pkg updating $portdir"
			fi

			pm_msg ''
			pm_msg "===>>> The dependency for ${origin}"
			pm_msg "       seems to be handled by $confl_p"
			pm_msg ''
		fi
	done
}

# changes PWD!!!
# Global: doing_dep_check
# Global: run_dl_g build_only_dl_g
dependency_check () {
	local dep_types d_port_list

	local portdir="$1"; shift
	local dep_types="$*"

	# Print a message here because sometimes list generation takes
	# a long time to return.
	if [ -z "$PM_INDEX_ONLY" ]; then
		pm_msg "===>>> Gathering dependency list for $portdir from ports"
	else
		pm_msg "===>>> Gathering dependency list for $portdir from ${PM_INDEX##*/}"
	fi
	d_port_list=$(gen_dep_list $portdir $dep_types)

	if [ -z "$d_port_list" ]; then
		pm_msg -e "===>>> No dependencies for $portdir\n"
		[ -n "$SHOW_WORK" ] && safe_exit
		return 0
	else
		if [ -n "$SHOW_WORK" ]; then
			pm_msg ''
		else
			pm_v "===>>> Starting dependency check"
		fi
	fi

	if [ "$PM_BUILD_ONLY_LIST" = pmp_doing_build_deps ]; then
		local rundeps dep varname run_dl build_only_dl

		rundeps=$(gen_dep_list $portdir run-depends-list)

		for dep in $d_port_list; do
			# If the port is already installed, do not mark
			# it as a build-only dependency, or it will be
			# installed by package and/or removed
			pkg info -e ${dep#$pd/} &&
				run_dl="$run_dl $dep" &&
				continue
			case "$rundeps" in
			*" ${dep} "*|*${dep}*)
				varname=$(echo ${dep#$pd/} | sed 's#[-+/\.@]#_#g')
				rundep_list="$rundep_list $varname"
				eval export $varname=\"$portdir \$$varname\"
				eval export ${varname}_p=$dep

				run_dl="$run_dl $dep" ;;
			*)
				build_only_dl="$build_only_dl $dep" ;;
			esac
		done

		if [ -z "$PM_THOROUGH" ]; then
			d_port_list="$build_only_dl $run_dl"
		else
			build_only_dl=$(gen_dep_list $portdir build-depends-list)
		fi

		run_dl_g="$run_dl_g $run_dl "

		for dep in $build_only_dl; do
			case "$build_only_dl_g" in
			*" ${dep} "*)
				;;
			*)
				build_only_dl_g="$build_only_dl_g $dep " ;;
			esac
		done

		clean_build_only_list $run_dl_g
	fi

	local d_port origin iport

	# Do not export, for THIS parent process only
	[ -n "$PM_FIRST_PASS" ] && doing_dep_check=doing_dep_check
	for d_port in $d_port_list; do
		origin="${d_port#$pd/}"
		if [ -n "$SHOW_WORK" ]; then
			iport=$(iport_from_origin $origin)
			case "$iport" in
			'')
				pm_msg "===>>> NOT INSTALLED		$origin" ;;
			*)
				pm_msg "===>>> Installed $origin" ;;
			esac
			continue
		fi

		pm_v "===>>> Checking dependency: $origin"

		# Do this first to catch out of date dependencies
		[ -n "$PM_FIRST_PASS" ] &&
			case "$PM_NEEDS_UPDATE" in
			*\ $origin\ *)
				continue ;;
			esac

		[ -z "$PM_URB_UP" ] &&
			case "$CUR_DEPS" in
			*:${origin}:*)
				continue ;;
			esac

		# check_conflicts may change d_port!
		[ -z "$PM_INDEX_ONLY" ] && check_conflicts "$portdir" "$origin"

		# In case d_port changed above
		origin="${d_port#$pd/}"
		iport=$(iport_from_origin ${origin})

		check_exclude ${iport:-$origin} || continue

		if [ -n "$PM_FORCE" -a -n "$iport" ]; then
			if ! check_restart_and_udf $iport; then
				pm_msg "===>>> Forcing update for $pd/$origin"
				update_port $iport
			else
				CUR_DEPS="${CUR_DEPS}${iport}:${originflavor}:"
			fi
			continue
		elif [ -n "$PM_URB_UP" -a -n "$iport" ]; then
			case "$PM_URB_DONE" in
			*:${iport}:*)
				already_done $iport
				continue ;;
			esac

			case " $PM_URB_LIST " in
			*" $iport "*)
				check_interactive $iport || continue
				if ! check_restart_and_udf $iport; then
					update_port $iport
				else
					CUR_DEPS="${CUR_DEPS}${iport}:${originflavor}:"
					PM_URB_DONE="${PM_URB_DONE}${upg_port}:"
				fi
				continue ;;
			esac
		fi

		if [ -n "$iport" ]; then
			# No check_interactive here because we want to tell
			# the user whether or not there is a new version first
			check_for_updates $iport $origin || fail 'Update failed'
		else
			check_interactive $origin || continue
			update_port $origin
		fi
	done
	[ -n "$PM_FIRST_PASS" ] && unset doing_dep_check

	if [ -n "$SHOW_WORK" ]; then
		safe_exit
	elif [ -n "$PM_FIRST_PASS" -a -z "$PM_PACKAGES" ]; then
		pm_msg -e "===>>> Initial dependency check complete for $portdir\n"
	else
		pm_msg "===>>> Dependency check complete for $portdir"
		local deps ; deps="(${dep_of_deps}/${num_of_deps})"
		case "$PM_DEPTH" in
		*\>\>*)
			term_printf " ${PM_DEPTH#* }${deps}" ; pm_msg '' ;;
		*)
			if [ "$PM_PARENT_PORT" = All ]; then
				term_printf " >> ${upg_port:-$portdir}${deps}"
			elif [ -n "$PM_URB_UP" ]; then
				term_printf " >> ${upg_port:-$portdir} ${deps}"
				pm_msg ''
			else
				term_printf ; pm_msg ''		# multiport
			fi ;;
		esac
	fi
} # dependency_check()

post_first_pass () {
	local portmsg action

	portmsg="$*"

	if [ ${num_of_deps:-0} -gt 0 ]; then
		term_printf " >> (${num_of_deps})"

		if [ -z "$PM_NO_CONFIRM" ]; then
			local answer

			pm_msg ''
			pm_msg "===>>> The following actions will be taken if you choose to proceed:"
			pm_msg -e "$build_l"
			get_answer_yn y "===>>> Proceed" || {
				pm_msg ''
				pm_msg "===>>> If you would like to upgrade or install some, but not"
				pm_msg "       all of the above try adding '-i' to the command line."
				safe_exit 1
			}
			unset build_l
		fi
	else
		term_printf
	fi

	# Only when -a or multi and user said no to update +IGNOREME(s)
	[ "$PM_NEEDS_UPDATE" = ' ' ] && return

	if [ -n "$FETCH_ONLY" ]; then
		action='fetch'
	elif [ "$PM_PACKAGES" = only ]; then
		action=install
	elif [ -n "$PM_PACKAGES" ]; then
		action='build and/or install'
	else
		action='build'
	fi

	pm_msg ''
	pm_msg "===>>> Starting $action for $portmsg <<<==="
	pm_msg ''

	unset PM_FIRST_PASS PM_NO_CONFIRM

	dep_of_deps=0

	if [ -n "$PM_BUILD_ONLY_LIST" ]; then
		local var real_rundep deplist dep temp_bodlg

		for var in $rundep_list ; do
			real_rundep=no

			eval deplist=\$$var
			for dep in $deplist ; do
				case "$build_only_dl_g" in
				*" $pd/$dep "*)
					;;
				*)
					real_rundep=yes ; break ;;
				esac
			done

			[ "$real_rundep" = 'no' ] &&
				eval build_only_dl_g=\"${build_only_dl_g}\$${var}_p \"
			eval unset $var ${var}_p
		done

		for dep in $build_only_dl_g ; do
			[ "$(pkg query "%?r" ${dep#$pd/})" = "1" ] && continue
			[ -n "$PM_DEL_BUILD_ONLY" ] &&
				iport_from_origin ${dep#$pd/} >/dev/null && continue
			temp_bodlg="$temp_bodlg $dep"
		done

		build_only_dl_g=" $(uniquify_list $temp_bodlg) "

		unset run_dl_g rundep_list
		PM_BUILD_ONLY_LIST=pm_bol
	fi
}

init_term_printf () {
	PM_PARENT_PORT=$1
	[ -z "$num_of_deps" ] && num_of_deps=0
	[ -z "$dep_of_deps" ] && dep_of_deps=0
	export PM_PARENT_PORT num_of_deps dep_of_deps

	term_printf
}

urb_update () {
	# Global: PM_URB_UP
	local verb origin req_by req_by_o

	verb=Checking ; [ -n "$1" ] && verb=Updating

	export PM_URB_UP=pm_urb_up

	init_term_printf "$verb ports that depend on $PM_URB_IPORTS"
	pm_msg ''
	PM_PARENT_PORT="$verb dependent ports"

	for origin in $PM_URB_ORIGINS ; do
		while read req_by req_by_o; do
			case " $PM_URB_IPORTS" in
			*" $req_by "*)
				continue ;;
			esac
			case " $PM_URB_ORIGINS" in
			*" $req_by_o "*)
				continue ;;
			esac
			PM_URB_LIST="${PM_URB_LIST} ${req_by}"
		done <<-EOF
		$(pkg query "%rn-%rv %ro" ${origin})
		EOF
	done

	if [ -n "$PM_URB_LIST" ]; then
		PM_URB_LIST="$(uniquify_list $PM_URB_LIST)"
		export PM_URB_LIST
	else
		pm_msg "===>>> No ports depend on $PM_URB_IPORTS"
		pm_msg ''
	fi

	for req_by in $PM_URB_LIST ; do
		# Probably not needed, but JIC
		pkg info -e $req_by || continue

		pm_v "===>>> $req_by depends on $PM_URB_IPORTS"

		case "$PM_URB_DONE" in
		*:${req_by}:*)
			already_done $req_by
			continue ;;
		esac

		check_exclude $req_by || continue
		check_interactive $req_by || continue

		# Shortcut, since check_for will force it
		if [ -z "$RESTART" -a -z "$PM_FORCE" ]; then
			update_port $req_by
		else
			check_for_updates $req_by || fail 'Update failed'
		fi
		pm_msg "===>>> Returning to list of ports depending on $PM_URB_IPORTS"
	done
	pm_msg ''
	pm_msg "===>>> $verb done for ports that depend on $PM_URB_IPORTS"
	pm_msg ''
	unset PM_URB_UP PM_URB_LIST PM_URB_DONE
}

multiport () {
	# Global
	PM_MULTI_PORTS=':' ; export PM_MULTI_PORTS

	local port worklist_temp iport worklist portlist numports origin num glob_dirs

	# Expand globs and check that the directories exist
	for port in "$@" ; do
		port=${port#$pdb/}
		case "$port" in
		*/*)
			port=${port#$pd/}
			if [ -n "$PM_INDEX_ONLY" ] || pm_isdir_pd "${port}"; then
				worklist_temp="$worklist_temp $port"
			else
				fail "$pd/${port} does not exist"
			fi ;;
		*)
			if pm_isdir "$pdb/$port" && pkg info -e $port; then
				worklist_temp="$worklist_temp $port"
			else
				glob_dirs=$(find_glob_dirs $port) || fail "$port is not installed"
				local dir
				for dir in $glob_dirs; do
					worklist_temp="$worklist_temp ${dir#$pdb/}"
				done
			fi ;;
		esac
	done

	numports=0
	for port in $worklist_temp; do
		check_exclude $port || continue
		check_interactive $port || continue

		if [ -n "$PM_UPDATE_IF_NEWER" ]; then
			case "$port" in
			*/*)
				iport=$(iport_from_origin $port) ;;
			*)
				iport=$port ;;
			esac

			if [ -n "$iport" ] && check_for_updates multi $iport; then
				if [ -n "$PM_URB" -a -n "$RESTART" ]; then
					pm_msg ''
					pm_msg "===>>> $iport is up to date, skipping rebuild due to -R flag"
					udl_prime="${udl_prime}${iport}:"
				elif [ -n "$PM_VERBOSE" ]; then
					pm_msg ''
					pm_msg "===>>> $port is up to date, skipping"
				fi
				continue
			fi
		fi

		numports=$(( $numports + 1 ))
		worklist="$worklist $port"
		portlist="${portlist}\t${port}\n"
		PM_MULTI_PORTS="${PM_MULTI_PORTS}${port}:"
	done
	unset PM_UPDATE_IF_NEWER

	if [ -z "$worklist" ]; then
		if [ -z "$PM_URB" ]; then
			pm_msg ''
			pm_msg "===>>> All listed ports are up to date, exiting"
			pm_msg ''
			safe_exit
		fi
	else
		pm_msg ''
		pm_msg "===>>> Working on:"
		pm_msg -e $portlist
	fi
	unset portlist

	[ -n "$DI_FILES" ] && (read_distinfos $DI_FILES)&

	# First Pass
	if [ -n "$PM_BUILD_ONLY_LIST" ]; then
		PM_BUILD_ONLY_LIST=pmp_doing_build_deps
		for port in $worklist; do
			case "$port" in
			*/*)
				run_dl_g="$run_dl_g ${pd}/${port} " ;;
			*)
				run_dl_g="$run_dl_g ${pd}/$(origin_from_pdb $port) " ;;
			esac
		done
	fi

	[ -n "$PM_URB" ] && export PM_URB

	num=0
	for port in $worklist; do
		case "$port" in
		*/*)
			origin=$port ;;
		*)
			origin=$(origin_from_pdb $port) ;;
		esac

		case "$PM_NEEDS_UPDATE" in
		*\ $origin\ *)
			numports=$(( $numports - 1 ))
			pm_v "===>>> $port already encountered as a dependency\n"
			continue ;;
		esac

		num=$(( $num + 1 ))
		init_term_printf "$port ${num}/${numports}"
		("$program" $ARGS $port) || update_failed=update_failed
		. $IPC_SAVE && > $IPC_SAVE
		[ -n "$update_failed" ] && fail "Update for $port failed"

		case "$PM_NEEDS_UPDATE" in
		*\ $origin\ *)
			continue ;;	# Handle +IGNOREME in child
		*)
			numports=$(( $numports - 1 )) ;;
		esac
	done

	if [ -n "$PM_URB" ]; then
		unset PM_URB ; PM_URB=pm_urb_post_first_pass
		PM_URB_DONE=":${udl_prime}" ; export PM_URB_DONE
		urb_update
	fi

	PM_PARENT_PORT="Total ports: $numports"

	check_fetch_only
	post_first_pass multiple ports

	[ -n "$PM_URB" ] && export PM_URB

	export PM_BUILDING=pmbuildingmultiport
	num=0
	for port in $worklist; do
		case "$port" in
		*/*)
			origin=$port ;;
		*)
			# If an installed version does not exist at this
			# point it probably got updated as a dependency
			if ! pkg info -e $port; then
				numports=$(( $numports - 1 ))
				continue
			fi
			origin=$(origin_from_pdb $port)
			unset PM_OLD_ORIGIN
			if [ -n "$origin" ] && ! pm_isdir_pd "$origin"; then
				export PM_OLD_ORIGIN=$origin
				find_moved_port $origin $port nonfatal && origin=$moved_npd
			fi ;;
		esac

		case "$PM_NEEDS_UPDATE" in
		*\ $origin\ *)
			;;		# Ok to proceed
		*)
			continue ;;	# Already updated as a dependency
		esac

		num=$(( $num + 1 ))
		init_term_printf "$port ${num}/${numports}"
		("$program" $ARGS $port) || update_failed=update_failed
		. $IPC_SAVE && > $IPC_SAVE
		[ -n "$update_failed" ] && fail "Update for $port failed"
	done

	if [ -n "$PM_URB" ]; then
		unset PM_URB ; PM_URB=pm_urb_post_build
		PM_URB_DONE=":${udl_prime}" ; export PM_URB_DONE
		urb_update urb_update_after_build
	fi

	if [ "$PM_PACKAGES" != 'only' ]; then
		check_fetch_only
	else
		check_fetch_only Package
	fi
	safe_exit
}

make_config () {
	local portdir config_type

	portdir="$1"
	[ -n "$PM_FORCE_CONFIG" ] && config_type=config || config_type=config-conditional

	pm_cd_pd "$portdir"
	pm_sv "Running 'make $config_type'"
	pm_make_s $config_type
}

#=============== End functions for main ===============

init_parent () {
	local PLB

	[ -f Makefile ] || pm_cd

	export CUR_DEPS=':'
	export DISPLAY_LIST=''
	export INSTALLED_LIST=''
	export PM_DEPTH=''
	export IPC_SAVE=$(pm_mktemp IPC_SAVE)
	export PM_FIRST_PASS=pm_first_pass
	export PM_NEEDS_UPDATE=' '	# Used with -F for multiport and -a

	if [ -n "$LOCALBASE" ]; then
		LOCALBASE_COMPAT="$LOCALBASE/lib/compat/pkg"
	elif [ -z "$FETCH_ONLY" ]; then
		PLB=$(pm_make_g -V LOCALBASE 2>/dev/null)
		if [ -n "$PLB" ]; then
			LOCALBASE_COMPAT="$PLB/lib/compat/pkg"
		else
			[ -n "$PM_INDEX" ] && PLB=$(head -1 $PM_INDEX | cut -f 3 -d\| 2>/dev/null)
			if [ -n "$PLB" ] && pm_idsdir "$PLB"; then
				LOCALBASE_COMPAT="${PLB}/lib/compat/pkg"
			else
				pm_msg "===>>> Unable to determine the value of LOCALBASE"
				pm_msg "       Try setting it in the environment, or /etc/make.conf"
				fail 'The value of LOCALBASE cannot be empty'
			fi
		fi
	fi
	export LOCALBASE_COMPAT

	if [ -n "$INTERACTIVE_UPDATE" ]; then
		INTERACTIVE_YES=':' ; INTERACTIVE_NO=':'
		export INTERACTIVE_YES INTERACTIVE_NO
	fi

	if [ -n "$PM_URB" -o -n "$PM_FORCE" ]; then
		if [ -z "$RESTART" ]; then
			files=$(find $pdb -type f -name PM_UPGRADE_DONE_FLAG)
			if [ -n "$files" ]; then
				pm_msg "===>>> There are 'install complete' flags from a previous"
				# <se>
				if get_answer_yn n "       -[rf] run of $progname, delete them"; then
					pm_sv Deleting \'install complete\' flags
					pm_find_s $pdb -type f -name PM_UPGRADE_DONE_FLAG -delete
				else
					get_answer_yn n "===>>> Enable the -R option" && {
						RESTART=Ropt
						ARGS="-R $ARGS"
					}
				fi
			fi
		fi
	fi

	if [ -z "$FETCH_ONLY" ]; then
		export NO_DEP_UPDATES=no_dep_updates
		export build_l=''
		export PM_WRKDIRPREFIX=$(pm_make_b -C $pd/Mk -V WRKDIRPREFIX)
	fi

	if [ -n "$PM_BUILD_ONLY_LIST" ]; then
		run_dl_g='' ; build_only_dl_g='' ; rundep_list=''
		export run_dl_g build_only_dl_g rundep_list
	fi
	if [ -n "$PM_DEL_BUILD_ONLY" ]; then
		export build_deps_il=''
	fi

	[ -z "$NO_BACKUP" ] && init_pbu_var
	[ -z "$NO_BACKUP" -a -z "$BACKUP" ] && export NB_DELETE
	if [ -n "$MAKE_PACKAGE" -a -z "$FETCH_ONLY" ]; then
		init_packages_var

		if ! pm_isdir "$PACKAGES"; then
			pm_sv Creating $PACKAGES
			pm_mkdir_s $PACKAGES
		fi
	fi

	# Set the file name here so it's visible to the children
	if [ -z "$DONT_SCRUB_DISTFILES" -a -z "$FETCH_ONLY" -a -z "$PM_PACKAGES" ]; then
		export DI_FILES=$(pm_mktemp DI-FILES)
	fi

	[ -n "$PM_URB" ] && multiport $PM_URB_IPORTS
	[ $# -gt 1 -a -z "$REPLACE_ORIGIN" ] && multiport "$@"
}

# This has to come after the initialization, it uses all the same stuff
all_first_pass () {
	local iport origin

	for iport in "$@"; do
		[ -z "$FETCH_ONLY" ] && pm_v "===>>> $iport"

		case "$CUR_DEPS" in
		*:${iport}:*)
			continue ;;
		esac

		origin=$(origin_from_pdb $iport) || {
			case "$?" in
			3)
				;;
			2)
				pm_v "	===>>> No ORIGIN for $iport, and +IGNOREME is present"
				pm_msg "	===>>> Skipping"
				pm_msg '' ;;	# <se> does "skipping" require some action???
			*)
				fail 'Cannot continue' ;;
			esac

			# Prevent the user from getting reprompted during build
			CUR_DEPS="${CUR_DEPS}${iport}:";
			continue; }

		case "$PM_NEEDS_UPDATE" in
		*\ $origin\ *)
			continue ;;
		esac

		[ -n "$PM_BUILD_ONLY_LIST" ] && run_dl_g="$run_dl_g ${pd}/${origin} "

		check_exclude $iport || continue

		PM_DEPTH="$iport "
		check_for_updates $iport $origin || fail 'Update failed'
	done
}

# Global: DI_FILES num_ports num_roots num_trunks num_branches num_leaves
update_all () {
	[ -n "$DI_FILES" ] && (read_distinfos $DI_FILES) &

	ports_by_category
	if [ -n "$FETCH_ONLY" ]; then
		# UPDATE_ALL is not exported
		export PM_ALL_FETCH=pm_all_fetch
		[ -n "$PM_FORCE" ] && num_of_deps=$num_ports
	fi

	init_term_printf All

	pm_msg "===>>> Starting check of installed ports for available updates"

	[ -n "$PM_BUILD_ONLY_LIST" ] && PM_BUILD_ONLY_LIST=pmp_doing_build_deps

	pm_v "\n===>>> Root ports: $num_roots"
	all_first_pass $roots

	pm_v "\n===>>> Trunk ports: $num_trunks"
	all_first_pass $trunks

	pm_v "\n===>>> Branch ports: $num_branches"
	all_first_pass $branches

	pm_v "\n===>>> Leaf ports: $num_leaves"
	all_first_pass $leaves

	check_fetch_only
	if [ -n "$NO_DEP_UPDATES" ]; then
		pm_msg ''
		pm_msg "===>>> All ports are up to date"
		pm_msg ''
		safe_exit
	fi

	post_first_pass 'ports that need updating'

	[ -n "$PM_BUILD_ONLY_LIST" ] && clean_build_only_list $run_dl_g

	export PM_BUILDING=pmbuildingall

	unset roots trunks branches leaves

	for origin in $PM_NEEDS_UPDATE; do
		case $PM_NEEDS_UPDATE in
		*\ $origin\ *)
			update_port $origin ;;
		*)
			continue ;;	# Already updated as a dependency
		esac
	done

	pm_msg "===>>> Update check of installed ports complete"
	pm_msg ''
	safe_exit
}

no_valid_port () {
	pm_msg ''
	pm_msg "===>>> No valid installed port, or port directory given"
	pm_msg "===>>> Try $progname --help"
	pm_msg ''
	safe_exit 1
}

# check use cases portdir="" and !=""
# Global: portdir upg_port pd pdb glob_dirs
prepare_update_new_origin () {
	local argv="$1"

	[ -n "$portdir" ] && {
		argv=$portdir # <se> ignore passed argument???
		unset portdir
	}
	argv=${argv%/}
	argv=$(globstrip $argv)
	export_flavor $(flavor_part $portdir)

	case "$argv" in
	$pd/*)
		portdir=${argv#$pd/} ;;
	$pdb/*)
		no_valid_port ;;
	/*)
		no_valid_port ;;
	*/*)
		portdir=$argv ;;
	\.|'')
		portdir="$PWD"
		while : ; do
			case "$portdir" in
			/)
				no_valid_port ;;
			*/*/*)
				portdir="${portdir#*/}" ;;
			*/*)
				break ;;
			*)
				no_valid_port ;;
			esac
		done ;;
	*)
		upg_port=$(pkg query %n-%v "$argv") ;;
	esac

	if [ -z "$portdir" -a -z "$upg_port" ]; then
		local glob_dirs=$(find_glob_dirs $argv)
		case $? in
		1)
			no_valid_port ;;
		2)
			multiport $glob_dirs ;;
		0)
			upg_port=${glob_dirs#$pdb/} ;;
		esac
	fi
}

# Global: portdir upg_port ro_upg_port ro_opd pd pdb glob_dirs
prepare_update_same_origin () {
	local arg2 glob_dirs

	portdir="${1#$pd/}" ; portdir="${portdir%/}"
	export_flavor=$(flavor_part $portdir)
	if [ -z "$PM_INDEX_ONLY" ]; then
		pm_isdir_pd "$portdir" ] || missing=missing
	else
		parse_index $portdir name >/dev/null || missing=missing
	fi

	if [ -n "$missing" ]; then
		pm_msg ''
		pm_msg "===>>> The first argument to -o must be a directory in $pd"
		no_valid_port
	fi

	upg_port=$(iport_from_origin $portdir) || upg_port=$opd
	arg2=${2#$pd/} ; arg2=${arg2#$pdb/} ; arg2=${arg2%/}

	case "$arg2" in
	*/*)
		ro_opd=$arg2 ; ro_upg_port=$(iport_from_origin $ro_opd) ;;
	*)
		if pm_isdir "$pdb/$arg2" && pkg info -e $arg2; then
			ro_upg_port=$arg2
		else
			glob_dirs=$(find_glob_dirs $arg2) && ro_upg_port=${glob_dirs#$pdb/}
		fi
		if [ -n "$ro_upg_port" ]; then
			ro_opd=$(origin_from_pdb $ro_upg_port)
		else
			ro_opd=$arg2
		fi ;;
	esac
	upg_port="${upg_port:-$ro_upg_port}"

	if [ -z "$ro_upg_port" ]; then
		pkg query -a "%do" | grep -q "^$ro_opd$"
		if [ "$?" -eq 1 ]; then
			pm_msg ''
			pm_msg "===>>> The second argument to -o can be a package name,"
			pm_msg "       or a port directory from $pd"
			pm_msg ''
			pm_msg "       $ro_opd does not seem to be installed,"
			pm_msg '       or listed as a dependency'
			no_valid_port
		fi
	fi

	PM_MAKE_ARGS="-DDISABLE_CONFLICTS $PM_MAKE_ARGS"
}

# Figure out what we are going to be working on
get_portdir () {
	if [ -n "$upg_port" ]; then
		portdir=$(origin_from_pdb $upg_port)
		case "$?" in
		0)
			;;
		2)
			pm_v "	===>>> No ORIGIN for $upg_port, and +IGNOREME is present\n"
			safe_exit 1 ;;
		3)
			pm_msg ''
			pm_msg "===>>> BSDPAN ports cannot be upgraded with portmaster"
			pm_msg "       (${upg_port})"
			pm_msg ''
			safe_exit 1 ;;
		*)
			fail 'Cannot continue' ;;
		esac
	else
		no_valid_port
	fi
}

check_moved () {
	local portdir upg_port moved_npd

	portdir="$1"
	upg_port="$2"

	find_moved_port $portdir $upg_port || no_valid_port
	[ -n "$moved_npd" ] || no_valid_port
	flavor=$(flavor_part "$moved_npd")
	export_flavor $flavor
	pm_isdir_pd "$moved_npd" || no_valid_port

	not_in_child && parent_exit
	exec "$program" $ARGS -o $moved_npd $upg_port
	# NOT REACHED
}

iport_from_pkgname () {
	local dir flavor pkgname

	dir=$(dir_part $1)
	flavor=$(flavor_part $1)
	pkgname=$(make -C "$pd/$dir" -V PKGNAME FLAVOR=$flavor) || return 1
	pkg info -x "^${pkgname%-*}"'-[^-]*' 2>/dev/null
}

pkg_origin () {
	iport_from_origin "$1" || iport_from_pkgname "$1" || pm_msg "$PM_OLD_ORIGIN"
}

ask_override_locked () {
	local upg_port="$1"
	# Adding to CUR_DEPS means we will not get here in the build
	if [ -z "$PM_BUILDING" ]; then
		# Only need to prompt for this once if -ai
		case "$INTERACTIVE_YES" in
		*:${upg_port}:*)
			;;	# Let it build
		*)
			if [ -z "$FETCH_ONLY" ]; then
				pm_msg ''
				pm_msg "===>>> $upg_port has an +IGNOREME file"

				get_answer_yn n "\t===>>> Update anyway" || {
					CUR_DEPS="${CUR_DEPS}${upg_port}:${portdir}:"
					if [ ${dep_of_deps:-0} -gt 0 ]; then
						dep_of_deps=$(( $dep_of_deps - 1 ))
						[ -n "$PM_FIRST_PASS" ] &&
							num_of_deps=$(( $num_of_deps - 1 ))
					fi
					safe_exit
				}
			else
				pm_msg ''
				pm_msg "===>>> $upg_port has an +IGNOREME file, ignoring"
				pm_msg ''
				CUR_DEPS="${CUR_DEPS}${upg_port}:${portdir}:"
				safe_exit
			fi ;;
		esac
	elif [ -n "$PM_URB_UP" ]; then
		pm_msg ''
		pm_msg "===>>> $upg_port has an +IGNOREME file, ignoring"
		pm_msg ''
		safe_exit
	fi
}

check_broken () {
	local portdir upg_port

	portdir="$1"
	upg_port="$2"
	if [ -z "$PM_INDEX_ONLY" ] && ! check_state; then
		check_state_fail=check_state_fail
		if [ -n "$PM_FORCE_CONFIG" ]; then
			sleep 4
			make_config "$portdir"
			check_state && unset check_state_fail
		fi
		if [ -n "$check_state_fail" ]; then
			pm_msg "	===>>> If you are sure you can build it, remove the"
			pm_msg "	       $state line in the Makefile and try again."
			safe_exit 1
		fi
	fi

	update_build_l $portdir $upg_port
}

background_checksum () {
	local portdir fetchlog

	portdir="$1"
	pm_msg "===>>> Launching 'make checksum' for $portdir in background"
	fetchlog=$(pm_mktemp fetchlog-${portdir#*/})
	(
		# do not use pm_make here!
		if ! make -DBATCH checksum; then
			allfiles=$(pm_make -V ALLFILES)
			pm_make delete-distfiles RESTRICTED_FILES="$allfiles" &&
				pm_msg "===>>> RE-STARTING FETCH <<<==="
			# do not use pm_make here!
			make -DBATCH checksum
		fi
		pm_rmtemp "*-${portdir#*/}"
	) > $fetchlog 2>&1 &
}

fetch_check_distfiles () {
	local portdir="$1"

	# PATCHFILES may get added after the first pass, but we want to
	# do as much of this as we can, as early as we can, and
	# patch files are usually small anyway.
	distfiles=$(make_distfiles $portdir)

	# Make sure that different ports using the same distfiles
	# do not clobber each other's fetchs
	for file in $distfiles; do
		case "$file" in
		*/*)
			file=$(echo $file | tr "/" "_") ;;
		esac
		if ! pm_lstemp "$file-*" >/dev/null; then
			pm_mktemp ${file}-${portdir#*/} >/dev/null
		else
			[ -n "$FETCH_ONLY" ] &&
				pm_msg "===>>> Skipping $file due to previous fetch for it"
			DONT_FETCH=dont_fetch
			break
		fi
	done

	if [ -z "$DONT_FETCH" -a -n "$distfiles" ]; then
		background_checksum $portdir
	fi
}

check_warn_interactive () {
	local TESTINT DISCARD

	TESTINT=$(grep -l ^IS_INTERACTIVE Makefile) && TESTINT=$(pm_make_b -V IS_INTERACTIVE)
	if [ -n "$TESTINT" ]; then
		pm_msg ''
		pm_msg "===>>> Warning: $portdir is interactive, and will likely"
		pm_msg "       require attention during the build"
		pm_msg ''
		pm_msg -n "===>>> Press the [Enter] or [Return] key to continue "
		read DISCARD
		pm_msg ''
	fi
}

fetch_package () {
	# Global: ppd FETCH_ARGS
	local do_fetch

	if [ -z "$ppd" ]; then
		init_packages_var
		ppd=$PACKAGES/portmaster-download
		export ppd
	fi

	pm_isdir "$ppd" ] || { pm_sv Creating $ppd; pm_mkdir_s $ppd; }

	if [ -z "$FETCH_ARGS" ]; then
		FETCH_ARGS=$(pm_make_g -V FETCH_ARGS 2>/dev/null)
		[ -n "$FETCH_ARGS" ] || FETCH_ARGS='-ApRr'
		export FETCH_ARGS
	fi

	if [ -z "$PM_ALWAYS_FETCH" ]; then
		if [ -r "${ppd}/${1}.txz" ]; then
			pm_v "===>>> Package exists, skipping fetch"
			return 0
		else
			do_fetch=do_fetch_no_package
		fi
	else
		do_fetch=do_fetch_always_fetch
		pm_unlink_s ${ppd}/${1}.txz
	fi

	if [ -n "$do_fetch" ]; then
		if [ -n "$PM_VERBOSE" ]; then
			if [ -n "$2" ]; then
				pm_msg "===>>> Trying to fetch $1 directly"
			else
				pm_msg "===>>> Starting package fetch"
			fi
		fi

		pm_sv Fetching ${1}.txz
		if ! $PM_SU_CMD fetch $FETCH_ARGS -o $ppd ${sitepath}${1}.txz 2>/dev/null; then
			pm_unlink_s ${ppd}/${1}.txz
			$PM_SU_CMD fetch $FETCH_ARGS -o $ppd ${sitepath}${1}.txz 2>/dev/null
		fi
	fi
}

prepare_fetch () {
	local DI_FILES portdir master_sites

	portdir="$1"
	DI_FILES="$2"

	# Do not start this in the background until we are sure we are going to proceed
	not_in_child && [ -n "$DI_FILES" ] && (read_distinfos $DI_FILES)&

	# Handle the problem of manual fetching
	[ -z "$PM_PACKAGES" ] && master_sites=$(pm_make -V MASTER_SITES)

	if [ -n "$master_sites" ]; then
		fetch_check_distfiles $portdir
	elif [ -n "$FETCH_ONLY" ]; then
		pm_msg "===>>> No distfiles to fetch"
	fi

	if [ -z "$FETCH_ONLY" -a ! "$PM_PACKAGES" = only ]; then
		check_warn_interactive
	else
		[ -n "$PM_ALL_FETCH" ] && safe_exit
	fi
}

first_pass_config_deps () {
	local portdir dep_check_type

	portdir="$1"

	not_in_child && [ -n "$PM_BUILD_ONLY_LIST" ] &&
		PM_BUILD_ONLY_LIST=pmp_doing_build_deps

	if [ -z "$PM_PACKAGES" ]; then
		[ -z "$PM_NO_MAKE_CONFIG" ] && make_config "$portdir"

		[ -n "$PM_THOROUGH" ] && dep_check_type=all-depends-list ||
				dep_check_type="build-depends-list run-depends-list"

	else
		dep_check_type=run-depends-list
	fi

	dependency_check "$portdir" "$dep_check_type"

	[ -n "$PM_URB" -o -n "$PM_URB_UP" ] &&
		PM_URB_DONE="${PM_URB_DONE}${upg_port}:"

	not_in_child || safe_exit

	check_fetch_only
	post_first_pass $portdir
}

choose_build_type () {
	local portdir="$1"

	if [ -n "$PM_BUILD_ONLY_LIST" ]; then
		case "$build_only_dl_g" in
		*" $pd/$portdir "*|*" $portdir "*)
			[ -n "$PM_PACKAGES_BUILD" ] && PM_PACKAGES_BUILD=doing_build_only_dep
			[ -n "$PM_DEL_BUILD_ONLY" ] && PM_DEL_BUILD_ONLY=doing_build_only_dep ;;
		*)
			[ -n "$PM_PACKAGES_BUILD" ] && PM_PACKAGES_BUILD=pmp_build
			[ -n "$PM_DEL_BUILD_ONLY" ] && PM_DEL_BUILD_ONLY=pm_dbo ;;
		esac
	fi
}

find_dependencies () {
	local portdir="$1"

	if [ -z "$NO_DEP_UPDATES" ]; then
		pm_cd_pd $portdir
		if [ -z "$PM_THOROUGH" ]; then
			if [ -z "$PM_PACKAGES" ]; then
				pm_msg "===>>> Starting check for build dependencies"
				dependency_check "$portdir" build-depends-list
			fi
		else
			pm_msg "===>>> Starting check for all dependencies"
			if [ -z "$PM_PACKAGES" ]; then
				dependency_check "$portdir" all-depends-list
			else
				dependency_check "$portdir" run-depends-list
			fi
		fi
		pm_cd_pd $portdir
	elif not_in_child; then
		pm_msg "===>>> All dependencies are up to date"
		pm_msg ''
	fi
}

init_sitepath () {
	local release major_rel arch

	if [ -z "$PACKAGESITE" -a -z "$PM_PACKAGES_LOCAL" ]; then
		release=$(uname -r)
		major_rel=${release%.*}
		arch=$(uname -p)

		sitepath="${PACKAGEROOT:-"http://pkg.freebsd.org"}/FreeBSD:$major_rel:$arch/latest/All/"
	else
		sitepath="${PACKAGESITE%/}"
		sitepath="${sitepath%Latest}"
		sitepath="${sitepath%All}"
	fi
}

check_local_package () {
	local new_port local_package s

	new_port="$1"
	if [ -n "$LOCAL_PACKAGEDIR" ]; then
		pm_v "===>>> ... checking: ${LOCAL_PACKAGEDIR}/All/${new_port}.txz"
		if [ -r "${LOCAL_PACKAGEDIR}/All/${new_port}.txz" ]; then
			local_package=${LOCAL_PACKAGEDIR}/All/${new_port}.txz
			pm_msg ${local_package##*/}
		elif [ -z "$PM_INDEX_ONLY" ]; then
			s=$(pm_make -V PKGLATESTFILE)

			pm_msg "===>>> ... checking: ${s}"
			if [ -r "${s}" ]; then
#				local_package=${s}
				latest_pv=$(readlink ${s})
				pm_msg ${latest_pv##*/}
			fi
		fi
	fi
}

check_remote_package () {
	local portdir new_port dirlist s

	portdir="$1"
	new_port="$2"
	dirlist=$(pm_lstemp dl-${portdir%/*})
	if [ ! -r "$dirlist" ]; then
		pm_unlink $dirlist		# JIC
		dirlist=$(pm_mktemp dl-${portdir%/*})
		fetch -q -o - ${sitepath} 2>/dev/null |
			sed -e "s#%2[cC]#,#g" -e "s#%2[bB]#+#g" > $dirlist
	fi

	for s in ${new_port%\.*} ${new_port%%\.*} ${new_port%-*}; do
		grep -m1 "href=\"${s}" $dirlist && return
	done
}

notnewer_msg () {
	pm_msg ''
	pm_msg "===>>> The newest available package ($latest_pv)"
	pm_msg "       is not newer than the installed version ($upg_port)"
}

print_package_not_found () {
	local new_port="$1"

	pm_msg "===>>> Package and/or archive not found at:"
		if [ -n "$LOCAL_PACKAGEDIR" ]; then
			pm_msg "	$LOCAL_PACKAGEDIR"
			[ -z "$PM_PACKAGES_LOCAL" ] && pm_msg '	or'
		fi
		[ -z "$PM_PACKAGES_LOCAL" ] && pm_msg "	${sitepath}"
		pm_msg ''
		pm_msg "       Check the pkg-add(8) man page for information"
		pm_msg "       on setting the PACKAGESITE environment variable"
		[ "$PM_PACKAGES" = only -a -z "$FETCH_ONLY" ] && fail $ponly_err
		if [ -n "$FETCH_ONLY" ]; then
			while : ; do
				pm_msg -e "\n===>>> There is no valid package to install\n"
				pm_msg "===>>> Abort update         [a]"
				pm_msg "===>>> Retry fetch          [r]"
				pm_msg "===>>> Continue if possible [c]"
				pm_msg -e "\n===>>> How would you like to proceed? [a] \c"
				read answer
				pm_msg ''

				case "$answer" in
				''|[aA])
					fail "No package exists for $new_port" ;;
				[rR])
					if fetch_package $new_port try ; then
						latest_pv=$new_port
						break
					fi ;;
				[cC])
					safe_exit ;;
				*)
					pm_msg "	===>>> $answer is not a valid response" ;;
				esac
			done
			unset answer
		fi
}

# sets global latest_pv
try_install_package () {
	local portdir new_port ponly_err

	portdir="$1"
	new_port="$2"

	pm_msg "===>>> Checking package repository for latest available version"

	[ -n "$sitepath" ] || init_sitepath

	latest_pv=$(check_local_package "$new_port")

	if [ -z "$latest_pv" ]; then
		pm_v "===>>> No local package for ${new_port}, attempting fetch"
		[ -z "$PM_PACKAGES_LOCAL" ] && latest_pv=$(check_remote_package "$portdir" "$new_port")
	fi

	if [ -z "$latest_pv" ]; then
		[ -z "$PM_PACKAGES_LOCAL" ] && { fetch_package $new_port try && latest_pv=$new_port; }
	fi

	ponly_err="Try --packages-if-newer, or do not use -PP/--packages-only"

	if [ -z "$latest_pv" ]; then
		print_package_not_found "$new_port"
	else
		latest_pv=${latest_pv#*href=\"}
		latest_pv=${latest_pv%%\.txz*}
	fi

	if [ "$latest_pv" = "$new_port" ]; then
		use_package=up_equal
		pm_v "===>>> Available package ($latest_pv) matches the current version"
	elif [ -n "$latest_pv" ]; then
		if [ -n "$PM_PACKAGES_NEWER" ]; then
			if [ -n "$upg_port" ]; then
				case $(pkg version -t $upg_port $latest_pv) in
				\<)
					use_package=up_newer
					pm_v "===>>> Available package ($latest_pv)"
					pm_v "       is newer than installed ($upg_port)" ;;
				=)
					if [ -n "$PM_FORCE" ]; then
						use_package=up_force
					else
						notnewer_msg
					fi ;;
				*)
					notnewer_msg ;;
				esac
			else
				use_package=up_no_installed
				pm_v "===>>> There is a package available ($latest_pv)"
			fi
		else
			case $(pkg version -t $new_port $latest_pv) in
			\<)
				# Could happen if ports tree is out of date
				use_package=up_old_tree
				pm_v "===>>> Available package ($latest_pv)"
				pm_v "       is newer than ports tree ($new_port)" ;;
			=)
				;;	# Should not be reached
			*)
				# Packages like autoconf-2.1* vs. 2.6* can be false neg.
				fetch_package $new_port try
				if [ $? -eq 0 ]; then
					latest_pv=$new_port
					use_package=up_auto
				else
					pm_msg ''
					pm_msg "===>>> The newest available package ($latest_pv)"
					pm_msg "       is older than the version in ports ($new_port)"
					if [ "$PM_PACKAGES" = only ]; then
						if [ -n "$PM_FORCE" ]; then
							use_package=up_force2
							pm_msg "===>>> Installing anyway due to -f"
						else
							fail $ponly_err
						fi
					fi
				fi ;;
			esac
		fi
	fi

	if [ -n "$use_package" ]; then
		new_port=$latest_pv
	else
		if [ "$PM_PACKAGES" = only ]; then
			fail "There is no valid package to install"
		else
			pm_msg ''
			[ -n "$FETCH_ONLY" ] && safe_exit
			pm_msg "===>>> There is no valid package to install, building port instead"
			pm_msg ''
		fi
	fi
}

wait_fetch_complete () {
	local portdir fl_read count

	portdir="$1"
	fl_read=$(pm_lstemp fetchlog-${portdir#*/})
	count=0
	while [ -f "$fl_read" ]; do
		count=$(( $count + 1 ))
		if [ $count -eq 1 ]; then
			pm_msg "===>>> Waiting on fetch & checksum for $portdir <<<==="
			tail -10 $fl_read 2>/dev/null
			pm_msg ''
			pm_msg ''
		elif [ $count -eq 3 ]; then
			count=0
		fi
		sleep 2
	done
}

# Return flavor for named pkg (must be executed in port directory!)
flavor_from_pkg () {
	local pkg="$1" flavor
	pm_make pretty-flavors-package-names | sed -ne 's!^\([A-Za-z0-9_]*\): *'$pkg'$!\1!p';
}

# sets global variables port_log port_log_args
build_port () {
	local portdir=$1

	pm_cd_pd $portdir
	export_flavor $(flavor_part $portdir)

	if [ -n "$PM_PACKAGES" ]; then
		[ -z "$PM_NO_MAKE_CONFIG" ] && make_config "$portdir"

		if [ -z "$PM_THOROUGH" ]; then
			pm_msg "===>>> Starting check for build dependencies"
			dependency_check "$portdir" build-depends-list
		fi
	fi

	if [ -z "$DONT_PRE_CLEAN" ]; then
		pm_make_s clean NOCLEANDEPENDS=ncd || fail 'make clean failed'
	fi

	wait_fetch_complete "$portdir"

	if [ -n "$HIDE_BUILD" ]; then
		port_log=$(/usr/bin/mktemp -t port_log-${PM_PARENT_PID}-${portdir#*/}) ||
			fail "mktemp for port_log-${PM_PARENT_PID}-${portdir#*/} failed"
		port_log_args=">> $port_log 2>&1"
		pm_msg "===>>> Logging build to $port_log"
	fi

	[ -n "$PM_NO_MAKE_CONFIG" ] && PM_MAKE_ARGS="$PM_MAKE_ARGS -D_OPTIONS_OK"

	export_flavor=$(flavor_from_pkg $new_port)
	eval pm_make build $port_log_args || fail "make build failed for $portdir"

	pm_sv Running make stage
	# Defining NO_DEPENDS ensures that we will control the installation
	# of the depends, not bsd.port.mk.
	eval pm_make -DNO_DEPENDS stage $port_log_args || fail "make stage failed for $portdir"
}

# Global: LOCALBASE_COMPAT
save_shared_libs () {
	local upg_port non_local_shlibs file temp

	upg_port="$1"
	non_local_shlibs=" $(echo $(ldconfig -r | sed 's#.* ##' | grep -v ^$LOCALBASE_COMPAT | grep -v ':' )) "

	for file in $(pkg query %Fp $upg_port); do
		case "$non_local_shlibs" in
		*" $file "*)
			temp="${temp}$file " ;;
		esac
	done
	if [ -n "$temp" ]; then
		if ! pm_isdir "$LOCALBASE_COMPAT"; then
			pm_sv "Creating $LOCALBASE_COMPAT for -w"
			pm_mkdir_s $LOCALBASE_COMPAT
		fi

		pm_sv 'Copying old shared libraries for -w'
		$PM_SU_CMD cp -p $temp ${LOCALBASE_COMPAT}/
		pm_sv Running ldconfig
		$PM_SU_CMD /etc/rc.d/ldconfig start > /dev/null
	fi
}

# uses global variables SAVE_SHARED LOCALBASE_COMPAT np_orphan
pre_install_tasks () {
	local upg_port portdir file

	portdir="$1"
	ro_upg_port="$2"
	upg_port="${3:-$ro_upg_port}"

	# the invocation of init_pbu_var should be redundant, but pbu is not defined, without???
	[ -z "$NO_BACKUP" ] && init_pbu_var && pm_pkg_create "$pbu" $upg_port $portdir

	[ -n "$SAVE_SHARED" ] && save_shared_libs $upg_port

	find_dl_distfiles $portdir $upg_port

	if [ -n "$REPLACE_ORIGIN" -a -n "$ro_upg_port" ]; then
		# Delete any existing versions of the old port
		np_orphan=$(pkg query "%a" $ro_upg_port)
		pm_sv "Running pkg delete for $ro_upg_port"
		pm_pkg_delete_s $ro_upg_port
	fi

	# Could be empty if -o
	if [ -n "$upg_port" ]; then
		case " $PM_PRESERVE_PORTS " in
		*" $portdir "*)
			preserve_port=$(echo $portdir | sed 's#[-+/\.@]#_#g')
			eval preserve_port_files="\$${preserve_port}_files"
			preserve_dir=$(/usr/bin/mktemp -d ${TMPDIR}/d-${PM_PARENT_PID}-${preserve_port} 2>/dev/null) ||
				fail "Could not create a temporary directory for $preserve_port in $TMPDIR"
			for file in $preserve_port_files; do
				cp -p $file ${preserve_dir}/ ||
				    fail "Cannot copy $file, which is in \$${preserve_port}_files"
			done
			unset preserve_port files ;;
		esac

		# If $ro_upg_port was non-automatic, keep its state
		if [ "${np_orphan:-1}" -eq 1 ]; then
			np_orphan=$(pkg query "%a" $upg_port)
		fi
		pm_sv "Running pkg delete for $upg_port"
		pm_pkg_delete_s $upg_port
	fi

	pm_msg ''
	pm_cd_pd $portdir
}

install_failed () {
	upg_port="${ro_upg_port:-$upg_port}"

	if [ -z "$NO_BACKUP" -a -n "$upg_port" ]; then
		pm_msg ''
		pm_msg "===>>> A backup package for $upg_port should"
		pm_msg "       be located in $pbu"
	fi
	fail "Installation of $1 ($portdir) failed"
}

install_port () {
	local portdir="$1" upg_port="$2" new_port="$3"

	pm_sv Running make install

	if [ -z "$PM_SU_UNSET_PORT_LOG_ARGS" ]; then
		[ -n "$HIDE_BUILD" ] && pm_msg "===>>> Logging install to $port_log"
	else
		unset port_log_args
	fi

	if [ -z "$np_orphan" -a -z "$UPDATE_ALL" -a -z "$REPLACE_ORIGIN" -a -z "$PM_URB" ]; then
		if [ -n "$PM_MULTI_PORTS" ]; then
			case "$PM_MULTI_PORTS" in
			*:${upg_port:-NONE}:*)
				np_orphan=0 ;;
			*:${portdir}:*)
				np_orphan=0 ;;
			esac
		else
			not_in_child && np_orphan=0
		fi
	fi
	[ "${np_orphan:-1}" -eq 1 ] && PM_MAKE_ARGS="${PM_MAKE_ARGS} -DINSTALLS_DEPENDS"
	unset np_orphan
	# Defining NO_DEPENDS ensures that we will control the installation
	# of the depends, not bsd.port.mk.
	eval pm_make_s -DNO_DEPENDS install $port_log_args || install_failed $new_port
}

install_package () {
	local portdir="$1" latest_pv="$2"

	[ -n "$latest_pv" ] && ppd=${LOCAL_PACKAGEDIR}/All

	pm_msg "===>>> Installing package from: ${ppd}/${latest_pv}.txz"
	if $PM_SU_CMD pkg add --accept-missing --force ${ppd}/${latest_pv}.txz; then
		if [ -n "$PM_DELETE_PACKAGES" ]; then
			pm_v "===>>> Deleting ${latest_pv}.txz"
			pm_unlink_s ${ppd}/${latest_pv}.txz
		fi
	else
		install_failed ${latest_pv}.txz
	fi
}

# Remove saved libs that match newly installed files
delete_old_compat_libs () {
	local new_port temp file files

	new_port="$1"
	temp=$(find $LOCALBASE_COMPAT -type d -empty 2>/dev/null)
	if [ -z "$temp" ] && pm_isdir "$LOCALBASE_COMPAT"; then
		for file in $(pkg query %Fp $new_port); do
			[ -f "${LOCALBASE_COMPAT}/${file##*/}" ] &&
				files="${files}${LOCALBASE_COMPAT}/${file##*/} "
		done

		if [ -n "$files" ]; then
			pm_sv Removing old shared libraries, and running ldconfig
			pm_rm_s $(make -V FILES:O:u FILES="$files")
			$PM_SU_CMD /etc/rc.d/ldconfig start > /dev/null
		fi
	fi
	[ -n "$temp" ] || temp=$(find $LOCALBASE_COMPAT -type d -empty 2>/dev/null)
	if pm_isdir "$temp"; then
		pm_sv Deleting the empty $LOCALBASE_COMPAT
		pm_rmdir_s $temp
	fi
}

# Implement storage of distfile information in the way that
# it will (hopefully, soon?) be implemented in bsd.port.mk
# See http://www.freebsd.org/cgi/query-pr.cgi?pr=106483
keep_distfiles_info () {
	local file dist_list portdir new_port port_subdir distinfo dist_list_temp line

	portdir="$1"
	new_port="$2"
	shift 2
	distfiles="$*"

	dist_list="${pdb}/${new_port}/distfiles"

	port_subdir=$(make_port_subdir $portdir)

	if [ -s distinfo ]; then
		distinfo=distinfo
	else
		distinfo=$(pm_make -V DISTINFO_FILE)
		[ -n "$distinfo" ] || fail "No DISTINFO_FILE in $portdir"
	fi

	dist_list_temp=$(pm_mktemp dist_list)
	echo '# Added by portmaster' > $dist_list_temp

	for file in $distfiles; do
		while read line ; do
			case "$line" in
			"SHA256 ($port_subdir$file)"*)
				sha256=${line##* }
				[ -z "$size" ] && continue ;;
			"SIZE ($port_subdir$file)"*)
				size=${line##* }
				[ -z "$sha256" ] && continue ;;
			esac
			echo "DISTFILE:$port_subdir$file:SIZE=$size:SHA256=$sha256" >> $dist_list_temp
			unset sha256 size
			break
		done < $distinfo

		# Make sure any new distfiles get added to the list
		! not_in_child && [ -n "$DI_FILES" ] &&
			echo "${port_subdir}${file}" >> $DI_FILES
	done

	pm_sv "Installing $dist_list\n"
	pm_mkdir_s ${dist_list%/*}
	pm_install_s $dist_list_temp $dist_list
	pm_unlink $dist_list_temp
}

# Global: PACKAGES
create_package () {
	local portdir new_port

	portdir="$1"
	new_port="$2"

	if [ -z "$use_package" ]; then
		pm_msg "===>>> Creating a package for new version $new_port"
		pm_make_s -D_OPTIONS_OK package >/dev/null || fail "Package creation of $new_port failed"
		pm_msg "	===>>> Package saved to $PACKAGES/All"
		pm_msg ''
	else
		pm_pkg_create $PACKAGES $new_port $portdir
	fi
}

background_clean () {
	local portdir=$(dir_part "$1")

	pm_v "===>>> Running 'make clean' in the background"
	(
		pm_cd_pd $portdir
		pm_make_s clean NOCLEANDEPENDS=ncd2 >/dev/null
	) &
	pm_v
}

update_package_dependencies () {
	local ro_portdir opd new_port

	portdir="$1"
	ro_opd="$2"
	new_port="$3"

	pm_msg "===>>> Updating dependency entry for $new_port in each dependent port"
	$PM_SU_CMD pkg set -yo $ro_opd:$portdir
}

install_type_msg () {
	local new_port upg_port portdir

	new_port="$3"
	upg_port=$(dir_part $2)	# <se> ?is new_port also without flavor?
	portdir="$1"
	case "$upg_port" in
	"$new_port")
		pm_msg "Re-installation of $upg_port" ;;
	'')
		pm_msg "Installation of $portdir ($new_port)" ;;
	*)
		pm_msg "Upgrade of $upg_port to $new_port" ;;
	esac
}

# ---------------------------------------------------------------------------
# Start of execution

if [ -z "$PM_PARENT_PID" ]; then
	initial_init
fi

if not_in_child; then
	init_pd_var
	init_pdb_var
	init_port_dbdir_var
fi

shortopts=
check_longopts "$@"	# sets shortopts
set -- $shortopts
unset shortopts

[ -n "$PM_INDEX" -a -n "$CHECK_PORT_DBDIR" ] &&
	fail 'The --index* and --check-port-dbdir options are mutually exclusive'

[ -n "$PM_PACKAGES_LOCAL" -a -z "$LOCAL_PACKAGEDIR" ] &&
	fail 'The --packages-local option requires --local-packagedir to be defined'

worklist=
check_opts "$@"	# sets worklist
set -- $worklist
unset worklist

check_opt_errs

[ -n "$PM_EXCL" ] && export PM_EXCL
[ -n "$PM_NO_MAKE_CONFIG" -a -n "$PM_FORCE_CONFIG" ] && unset PM_NO_MAKE_CONFIG
[ -n "$PM_PACKAGES" -a -n "$FETCH_ONLY" ] && export PM_NO_CONFIRM=pm_no_confirm

not_in_child && process_options "$@"

#=============== End Command Line Option Processing ===============
#=============== End code relevant only to getopts features ===============

[ -n "$CLEAN_DISTFILES" ]	&& { clean_distfiles;		safe-exit; }
[ -n "$CLEAN_PACKAGES" ]	&& { clean_packages;		safe_exit; }

[ -n "$CHECK_DEPENDS" ]		&& { pkg check -dn;		exit 0; }
[ -n "$CHECK_PORT_DBDIR" ]	&& { check_port_dbdir;		exit 0; }
[ -n "$LIST_ORIGINS" ]		&& { pkg query -e '%#r = 0' '%o'; exit 0; }
[ -n "$LIST" -o -n "$LIST_PLUS" ] && { list_ports;		exit 0; }
[ -n "$EXPUNGE" ]		&& { expunge;			exit 0; }
[ -n "$CLEAN_STALE" ]		&& { clean_stale;		exit 0; }

if [ -n "$PM_INDEX" ]; then
	fetch_index
	outdated_ports_from_index
fi

[ "$PM_PACKAGES" != only -a -z "$DONT_SCRUB_DISTFILES" ] &&
	[ -z "$DISTDIR" ] && fail 'The value of DISTDIR cannot be empty'

[ -n "$PM_URB" -a -n "$RESTART" ] && PM_UPDATE_IF_NEWER=pm_update_if_newer_urb

[ -z "$SHOW_WORK" ] && not_in_child && init_parent "$@"

[ -n "$UPDATE_ALL" ] && update_all

if [ -z "$REPLACE_ORIGIN" ]; then
	prepare_update_new_origin "$@"
else
	prepare_update_same_origin "$@"
fi

[ -z "$portdir" ] && get_portdir

# <se> recursively executes portmaster!!! Should call update_new_origin instead???
# <se> Should the following line come before the test of REPLACE_ORIGIN???
[ -z "$PM_INDEX_ONLY" ] && ! pm_isdir_pd "$portdir" && check_moved $portdir $upg_port

[ -z "$upg_port" -a -z "$REPLACE_ORIGIN" ] && upg_port=$(pkg_origin $portdir)

pm_islocked "$upg_port" && ask_override_locked "$upg_port"

if [ -z "$PM_INDEX_ONLY" ]; then
	pm_cd $(dir_part $pd/$portdir) || no_valid_port
	export_flavor $(flavor_part $portdir)
else
	new_port=$(parse_index $portdir name) ||
		fail "No entry for $portdir in $PM_INDEX"
fi

if [ -z "$PM_DEPTH" ]; then
	PM_DEPTH="${upg_port:-$portdir} "
	[ -z "$PM_PARENT_PORT" ] && init_term_printf ${upg_port:-$portdir}
else
	PM_DEPTH="${PM_DEPTH}>> ${upg_port:-$portdir} "
fi

pm_msg ''
[ -n "$upg_port" ] && pm_msg "===>>> Currently installed version: $upg_port"

pm_msg "===>>> Port directory: $pd/$portdir"
pm_msg ''

if [ -z "$FETCH_ONLY" ]; then
	[ -n "$PM_FIRST_PASS" ] && check_broken "$portdir" "$upg_port"
else
	[ -n "$PM_PACKAGES" ] && update_pm_nu "$portdir"
fi

# Do these things first time through
if [ -z "$PM_INDEX_ONLY" -a -z "$PM_BUILDING" -a -z "$SHOW_WORK" -a -z "$NO_ACTION" ]; then
	prepare_fetch "$portdir" "$DI_FILES"	# <se> is DI_FILES set???
fi

if [ -n "$PM_FIRST_PASS" ]; then
	first_pass_config_deps "$portdir"
fi

[ -z "$PM_BUILDING" ] && export PM_BUILDING=pmbuildingmain

choose_build_type "$portdir"

find_dependencies "$portdir"

if [ -n "$NO_ACTION" -a -z "$PM_FIRST_PASS" ]; then
	pm_v "===>>> Build canceled due to -n flag"
	safe_exit
fi

find_new_port $portdir

if [ -n "$PM_PACKAGES" -o "$PM_PACKAGES_BUILD" = doing_build_only_dep ]; then
	if [ -z $(pm_make_b -V PT_NO_INSTALL_PACKAGE) ]; then
		try_install_package $portdir $new_port
	else
		if [ "$PM_PACKAGES" = 'only' ]; then
			pm_msg "===>>> The -PP/--packages-only option was specified, but"
			pm_msg "       PT_NO_INSTALL_PACKAGE is defined for $portdir"
			fail These 2 options are mutually exclusive
		fi
		pm_msg "===>>> PT_NO_INSTALL_PACKAGE is set, building port"
		pm_msg ''
	fi
fi

if [ -z "$use_package" ]; then
	build_port "$portdir"
else
	[ -z "$latest_pv" ] && {
		fetch_package $latest_pv || fail "Fetch for ${latest_pv}.txz failed"; }
fi

# Ignore if no old port exists, or -F
if [ -n "$upg_port" -o -n "$ro_upg_port" ] && [ -z "$FETCH_ONLY" ]; then
	pre_install_tasks "$portdir" "$ro_upg_port" "$upg_port"
fi

if [ -z "$PM_THOROUGH" -a -z "$NO_DEP_UPDATES" ]; then
	pm_msg "===>>> Starting check for runtime dependencies"
	dependency_check "$portdir" run-depends-list
	pm_cd_pd $portdir
fi

if [ -n "$FETCH_ONLY" ]; then		# Only reached here if using packages
	CUR_DEPS="${CUR_DEPS}${new_port}:${portdir}:"
	not_in_child || safe_exit
	check_fetch_only Package
fi

if [ -z "$use_package" ]; then
	install_port $portdir $upg_port $new_port
else
	install_package $portdir $latest_pv
fi

if [ -n "$preserve_dir" ]; then
	rmdir $preserve_dir 2>/dev/null
	unset preserve_dir preserve_port_files
fi

pm_msg ''

[ "$PM_DEL_BUILD_ONLY" = doing_build_only_dep ] &&
	build_deps_il="$build_deps_il $new_port"

delete_old_compat_libs "$new_port"

if ! not_in_child || [ -n "$PM_URB" ]; then
	pm_msg "===>>> $ilist succeeded"
	pm_msg ''
fi

# This will serve for *delete*distfiles() as well
[ -z "$use_package" ] && distfiles=$(make_distfiles $portdir)

[ -n "$distfiles" ] && keep_distfiles_info $portdir $new_port $distfiles

[ -n "$MAKE_PACKAGE" ] && create_package $portdir $new_port

[ -z "$use_package" -a -z "$DONT_POST_CLEAN" ] && background_clean $portdir

[ -n "$ro_opd" ] && update_package_dependencies $portdir $ro_opd $new_port

ilist=$(install_type_msg $portdir $upg_port $new_port )

INSTALLED_LIST="${INSTALLED_LIST}\t${ilist}\n"

[ -n "$(pkg query %M $new_port)" ] && DISPLAY_LIST="${DISPLAY_LIST}$new_port "

CUR_DEPS="${CUR_DEPS}${new_port}:${portdir}:"

[ -n "$HIDE_BUILD" -a -n "$port_log" ] && pm_unlink $port_log

[ -n "$PM_URB" -o -n "$PM_URB_UP" ] && PM_URB_DONE="${PM_URB_DONE}${new_port}:"

[ -n "$PM_URB" -o -n "$PM_URB_UP" -o -n "$PM_FORCE" ] &&
	pm_mkdir_s $pdb/$new_port &&
	$PM_SU_CMD touch $pdb/$new_port/PM_UPGRADE_DONE_FLAG

if [ -z "$DONT_SCRUB_DISTFILES" ]; then
	delete_stale_distfiles $portdir $upg_port
	[ -n "$ro_opd" ] && delete_all_distfiles $ro_opd
fi

safe_exit

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#  Copyright (c) 2005-2012 Douglas Barton
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
#  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
#  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
#  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
#  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
#  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
#  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
#  SUCH DAMAGE.
